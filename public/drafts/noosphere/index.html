<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Noosphere concepts | The Essence of Software</title>
<meta name="keywords" content="">
<meta name="description" content="A Concept Exploration of Noosphere">
<meta name="author" content="Daniel Jackson">
<link rel="canonical" href="https://essenceofsoftware.com/drafts/noosphere/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.975c213687e3725078fea4c6a99c54b6db419fd121c9e4e30c596e892a20471d.css" integrity="sha256-l1whNofjclB4/qTGqZxUtttBn9EhyeTjDFluiSogRx0=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://essenceofsoftware.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://essenceofsoftware.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://essenceofsoftware.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://essenceofsoftware.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://essenceofsoftware.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-WRQ6HWW3ZW"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-WRQ6HWW3ZW', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="Noosphere concepts" />
<meta property="og:description" content="A Concept Exploration of Noosphere" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://essenceofsoftware.com/drafts/noosphere/" /><meta property="og:image" content="https://essenceofsoftware.com/eos-twitter-card.png"/><meta property="article:section" content="drafts" />
<meta property="article:published_time" content="2023-05-02T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-05-02T00:00:00+00:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://essenceofsoftware.com/eos-twitter-card.png"/>

<meta name="twitter:title" content="Noosphere concepts"/>
<meta name="twitter:description" content="A Concept Exploration of Noosphere"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Drafts",
      "item": "https://essenceofsoftware.com/drafts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Noosphere concepts",
      "item": "https://essenceofsoftware.com/drafts/noosphere/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Noosphere concepts",
  "name": "Noosphere concepts",
  "description": "A Concept Exploration of Noosphere",
  "keywords": [
    
  ],
  "articleBody": "Intro This is an attempt to apply the concept design framework of EOS to Gordon Brander’s Noosphere. Because I don’t understand Noosphere well, it will no doubt contain many errors, but it seemed like a fun and potentially useful exercise, both as a test for concept design and perhaps also to offer a different perspective to the design of Noosphere itself.\nIdentifying concepts The first step is to identify a collection of concepts that together can reproduce Noosphere’s basic functionality. Rather than starting with the concepts that Noosphere highlights (notably the central Sphere concept), I’ve followed the strategy of identifying concepts bottom-up, trying to be as granular as possible, and whenever possible reusing existing concepts that are domain independent.\nAfter identifying a concept, I attempt to describe it using the standard EOS structure: a name, a purpose for the concept, an operational principle (an archetypal scenario explaining how it’s used), a state schema, and some actions.\nCrucially, concepts can be generic, defined over some type variable (given after the name) which is bound when the concept is instantiated in a given design context.\nThe most basic concept seems to be the concept of a Notebook that is little more than a collection of notes:\nconcept Notebook [Note] purpose manage collection of owned notes principle // if you create a notebook and add a note // the note belongs to the notebook. create(b); add(b, n) {n in b.notes} state notes: Book one -\u003e set Note actions create (out b: Book) // create new book b delete (b: Book) // delete book b and its notes add (b: Book, n: Note) // add note n to book b remove (b: Book, n: Note) // remove note n from book b Related concepts. Notebook is similar to Folder, although notebooks usually can’t be nested. In contrast to Label (used, eg, to organize messages in Gmail) and Collection (used to organize photos in Lightroom), a note usually cannot belong to more than one notebook.\nDesign question: sharing. Can notes be shared between users? The Notebook concept does not allow a note to be shared between notebooks. A single notebook could be owned by multiple users, however. We might add an Ownership concept later.\nDesign question: mutability. Notebooks are mutable, but the concept does not commit to whether notes themselves are. In most existing apps (such as Notion), notes are indeed mutable, but they won’t be in Noosphere.\nDesign question: genericity. The Notebook concept allows any type of note, but in practice this will be restricted to some standard media type (text, rich text, image, audio, movie, etc).\nDesign question: minimality. The boring operational principle suggests that maybe there should be more to a notebook than this. Am I missing something?\nNow we turn to the notes themselves, and for now consider only a concept for textual notes:\nconcept Textnote purpose provide editable notes with textual content principle // if you open a buffer, edit some text in it, // and save the buffer to a note, then the note // contains the text open(b); edit(b,t); save(b, n) {n.content = t} state content: Note -\u003e one static Text current: Buffer -\u003e one Text actions open (out b: Buffer) // create a new buffer with empty text content open (n: Note, out b: Buffer) // create new buffer with text content of existing note edit (b: Buffer, t: Text) // update content of buffer b to be t save (b: Buffer, out n: Note) // create new note with content matching current content of buffer close (b: Buffer) // discard buffer and association with current text Related concepts. Textnote is similar to the File concept in GitHub’s web interface: when you open and edit a file in a repo, you’re modifying a buffer which you can then commit to create a new version of the file.\nDesign question: mutability. This concept introduces a type Note of immutable notes. The type Text is assumed to be the standard, mutable type of textual strings. The concept attempts to define the basic functionality needed for creating immutable notes incrementally; the idea is to introduce a mutable Buffer type for editing, which produces immutable notes on saving.\nNoosphere uses the conventional concept of content-addressable storage for naming notes, which I’ll attempt to define in a concept:\nconcept ContentAddress purpose name objects by content principle // if you hash an object, you can find it later // with the resulting address hash(t, a); get(a, t’) {t’ = t} state address: Text lone -\u003e one static Address actions hash (t: Text, out a: Address) // compute a new address and store it get (a: Address, out t: Text) // return text associated with an address forget (a: Address) // forget text associated with an address Design question: purpose. I am not sure how to express the purpose, that is what motivates this concept. It seems to be a combination of a naming scheme that works across storage sites (since an object implicitly carries its own name), and a kind of built in authentication (since modifying of corrupting an object will change its content and thus its name).\nDesign question: collisions. The state declaration says that each text maps to one address; that each address is mapped to by at most one (lone) text (asserting that collisions never happen). The mapping from text to address is static, so the address of a text cannot change. (Strictly speaking, the semantics of static might allow a text to be assigned an address, be forgotten, and then be assigned a different address. This might model a change of hash algorithm.)\nDesign question: content type. I’m assuming for now that the contents are text, since this is easily compatible with the Textnote concept introduced before. Obviously content addressing could apply to a lower level representation and could handle other media types uniformly.\nDesign question: indexing. The concept assumes some kind of index that comprises the state; at the moment, I’m not concerned with how this index might be localized, but will just assume it’s available globally. Given this, the role of the forget action isn’t clear.\nDesign question: notes with same content. Anticipating the concept composition, I’m wondering what will happen if you save a buffer whose text content is the same as that of an existing note. I suppose what will happen is that no new note will be created, and instead the new shorthand name that you provide for the note will be bound to the existing note (in addition to any existing shorthand names). There’s a slight snag here because the Textnote concept says a new note is create on save, but it won’t be true in this case.\nIn Noosphere, notebooks are named by public keys. The purpose of this, presumably, is to avoid having a global directory mapping principals or notebooks to public keys: instead they just carry their public keys in their names.\nconcept PublicKeyName [Principal] purpose simplify key distribution principle state public, private: Principal one static -\u003e one static Key actions generate (p: Principal, out pr, pu: Key) // generate new key pair for principal find (k: Key, out p: Principal) // return principal with public key k sign (t: Text, p: Principal, out s: Text) // sign text t with private key of p check (t: Text, p: Principal, s: Text, out valid: Bool) // with public key of p check signature s matches t Technical issue. Because concepts express state so abstractly (as relations), the difference between the key/principal relationship being in a global table and being carried by (a representation of) the principal itself isn’t made. This is a bit weird. For now, I’m not sure how to express the fact that the key is a name, except to provide an action to find a principal given a key, which is the quintessential naming lookup (and would presumably be missing in a key directory).\nDesign question. I’ve declared the key/principal relations to be static in both directions, which means that (a) you can’t assign a new key to an existing principal, and (b) you can’t assign a new principal to an existing key (even its principal no longer exists). If not, Noosphere would break because references to notebooks would change in meaning over time. Notebook owners will have to make sure they run key generation just once and look after their private keys carefully!\nContent addressable names and public key names are not mnemonic, so Noosphere introduces user-defined shorthands:\nconcept Shorthand [Context, Object] state resolve: Context, Short -\u003e one Object actions createContext (out c: Context) // create new context for resolving shorthands deleteContext (c: Context) // remove context and all its shorthands createShorthand (c: Context, o: Object, out s: Short) // store new shorthand for object o in context c deleteShorthand (c: Context, s: Short) // remove shorthand s from context c lookup (c: Context, s: Short, out o: Object) // remove shorthand s from context c Design issue: uniqueness. In a given context, a shorthand must name a unique object but the same shorthand can name different objects in different contexts. Shorthands are not canonical: the same object can have multiple shorthand names, even in the same context.\nDesign issue: mutability. The shorthand mapping is not static: a shorthand can name different objects at different times. In fact, this will be essential in Noosphere, since this will allow a shorthand to refer to the latest version of a note.\nTechnical issue: naming names. The target of a shorthand, represented by the type variable Object, may itself be a name in another naming concept.\nTechnical issue: shorthand name type. The Short type is abstracted here, but will usually just be a text string.\nTechnical issue: allocating contexts. The concept is generic in Context, anticipating the decision that a notebook will be a context. This means that some clever synchronization will be needed, so that a context doesn’t get allocated in two concepts at once.\nNoosphere has a simple kind of versioning, in which notes can point to their prior versions. I’ll model that with a generic versioning concept:\nconcept Version [Object] purpose access to and restoring of old versions principle // if you register p as previous version of o, // then you'll get p if you ask for o's previous register (o, p); getPrev (o, p') {p' = p} state previous: Object -\u003e lone Object actions register (o, prev: Object) // record that prev is previous version of o getPrev (o: Object, out prev: Object) // return previous version of o (it exists) Design issue: invariants. Each object can have at most one predecessor, but potentially any number of successors. Cycles aren’t permitted; in particular, an object can’t be its own previous version.\nDesign issue: interaction with content addressing. Suppose I have a note N1 and create a new version N2, but N2 happens to have the same content as N0, which already has its own previous version. What happens now?\nComposing concepts Notebook [Textnote.Note] Textnote ContentAddress [??] PublicKeyName [Principal] Shorthand [Notebook.Book, Textnote.Note] Shorthand [Notebook.Book, Notebook.Book] Version [Textnote.Note]\nTo resolve:\nsaving to note when context matches existing note allocating contexts To do\nadd objects to content address Questions. Can the previous version belong to another notebook? Why must shorthand contexts be associated with notebooks?\n",
  "wordCount" : "1878",
  "inLanguage": "en",
  "datePublished": "2023-05-02T00:00:00Z",
  "dateModified": "2023-05-02T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Daniel Jackson"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://essenceofsoftware.com/drafts/noosphere/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "The Essence of Software",
    "logo": {
      "@type": "ImageObject",
      "url": "https://essenceofsoftware.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://essenceofsoftware.com" accesskey="h" title="The Essence of Software (Alt + H)">The Essence of Software</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://essenceofsoftware.com/ask/" title="Q&amp;A">
                    <span>Q&amp;A</span>
                </a>
            </li>
            <li>
                <a href="https://essenceofsoftware.com/buy/" title="Buy">
                    <span>Buy</span>
                </a>
            </li>
            <li>
                <a href="https://essenceofsoftware.com/reviews/" title="Reviews">
                    <span>Reviews</span>
                </a>
            </li>
            <li>
                <a href="https://essenceofsoftware.com/author/" title="Author">
                    <span>Author</span>
                </a>
            </li>
            <li>
                <a href="https://essenceofsoftware.com/posts/" title="Goodies">
                    <span>Goodies</span>
                </a>
            </li>
            <li>
                <a href="https://essenceofsoftware.com/subscribe/" title="Subscribe">
                    <span>Subscribe</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Noosphere concepts
    </h1>
    <div class="post-description">
      A Concept Exploration of Noosphere
    </div>
    <div class="post-meta"><span title='2023-05-02 00:00:00 +0000 UTC'>May 2, 2023</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Daniel Jackson&nbsp;|&nbsp;<a href="https://forum.softwareconcepts.io" rel="noopener noreferrer" target="_blank">Comments</a>

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#intro" aria-label="Intro">Intro</a></li>
                <li>
                    <a href="#identifying-concepts" aria-label="Identifying concepts">Identifying concepts</a></li>
                <li>
                    <a href="#composing-concepts" aria-label="Composing concepts">Composing concepts</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="intro">Intro<a hidden class="anchor" aria-hidden="true" href="#intro">#</a></h2>
<p>This is an attempt to apply the concept design framework of <a href="https://essenceofsoftware.com">EOS</a> to Gordon Brander’s <a href="https://subconscious.substack.com/p/noosphere-a-protocol-for-thought">Noosphere</a>. Because I don’t understand Noosphere well, it will no doubt contain many errors, but it seemed like a fun and potentially useful exercise, both as a test for concept design and perhaps also to offer a different perspective to the design of Noosphere itself.</p>
<h2 id="identifying-concepts">Identifying concepts<a hidden class="anchor" aria-hidden="true" href="#identifying-concepts">#</a></h2>
<p>The first step is to identify a collection of concepts that together can reproduce Noosphere’s basic functionality. Rather than starting with the concepts that Noosphere highlights (notably the central <em>Sphere</em> concept), I’ve followed the strategy of identifying concepts bottom-up, trying to be as granular as possible, and whenever possible reusing existing concepts that are domain independent.</p>
<p>After identifying a concept, I attempt to describe it using the standard EOS <a href="https://essenceofsoftware.com/posts/distillation/#a-structure-for-describing-concepts">structure</a>: a <em>name</em>, a <em>purpose</em> for the concept, an <em>operational principle</em> (an archetypal scenario explaining how it’s used), a <em>state</em> schema, and some <em>actions</em>.</p>
<p>Crucially, concepts can be generic, defined over some type variable (given after the name) which is bound when the concept is instantiated in a given design context.</p>
<p>The most basic concept seems to be the concept of a <em>Notebook</em> that is little more than a collection of notes:</p>
<pre><code>concept Notebook [Note]
purpose
  manage collection of owned notes
principle
  // if you create a notebook and add a note
  // the note belongs to the notebook.
  create(b); add(b, n) {n in b.notes}
state
  notes: Book one -&gt; set Note
actions
  create (out b: Book)
    // create new book b
  delete (b: Book)
    // delete book b and its notes
  add (b: Book, n: Note)
    // add note n to book b
  remove (b: Book, n: Note)
    // remove note n from book b
</code></pre>
<p><strong>Related concepts</strong>. <em>Notebook</em> is similar to <em>Folder</em>, although notebooks usually can’t be nested. In contrast to <em>Label</em> (used, eg, to organize messages in Gmail) and <em>Collection</em> (used to organize photos in Lightroom), a note usually cannot belong to more than one notebook.</p>
<p><strong>Design question: sharing</strong>. Can notes be shared between users? The <em>Notebook</em> concept does not allow a note to be shared between notebooks. A single notebook could be owned by multiple users, however. We might add an <em>Ownership</em> concept later.</p>
<p><strong>Design question: mutability</strong>. Notebooks are mutable, but the concept does not commit to whether notes themselves are. In most existing apps (such as Notion), notes are indeed mutable, but they won’t be in Noosphere.</p>
<p><strong>Design question: genericity</strong>. The <em>Notebook</em> concept allows any type of note, but in practice this will be restricted to some standard media type (text, rich text, image, audio, movie, etc).</p>
<p><strong>Design question: minimality</strong>. The boring operational principle suggests that maybe there should be more to a notebook than this. Am I missing something?</p>
<p>Now we turn to the notes themselves, and for now consider only a concept for textual notes:</p>
<pre><code>concept Textnote
purpose provide editable notes with textual content
principle
  // if you open a buffer, edit some text in it,
  // and save the buffer to a note, then the note
  // contains the text
  open(b); edit(b,t); save(b, n) {n.content = t}
state
  content: Note -&gt; one static Text
  current: Buffer -&gt; one Text
actions
  open (out b: Buffer)
    // create a new buffer with empty text content
  open (n: Note, out b: Buffer)
    // create new buffer with text content of existing note
  edit (b: Buffer, t: Text)
    // update content of buffer b to be t
  save (b: Buffer, out n: Note)
    // create new note with content matching current content of buffer
  close (b: Buffer)
    // discard buffer and association with current text
</code></pre>
<p><strong>Related concepts</strong>. <em>Textnote</em> is similar to the <em>File</em> concept in GitHub’s web interface: when you open and edit a file in a repo, you’re modifying a buffer which you can then commit to create a new version of the file.</p>
<p><strong>Design question: mutability</strong>. This concept introduces a type <em>Note</em> of immutable notes. The type <em>Text</em> is assumed to be the standard, mutable type of textual strings. The concept attempts to define the basic functionality needed for creating immutable notes incrementally; the idea is to introduce a mutable <em>Buffer</em> type for editing, which produces immutable notes on saving.</p>
<p>Noosphere uses the conventional concept of content-addressable storage for naming notes, which I’ll attempt to define in a concept:</p>
<pre><code>concept ContentAddress
purpose name objects by content
principle
  // if you hash an object, you can find it later
  // with the resulting address
  hash(t, a); get(a, t’) {t’ = t}
state
  address: Text lone -&gt; one static Address
actions
  hash (t: Text, out a: Address)
    // compute a new address and store it
  get (a: Address, out t: Text)
    // return text associated with an address
  forget (a: Address)
    // forget text associated with an address
</code></pre>
<p><strong>Design question: purpose</strong>. I am not sure how to express the purpose, that is what motivates this concept. It seems to be a combination of a naming scheme that works across storage sites (since an object implicitly carries its own name), and a kind of built in authentication (since modifying of corrupting an object will change its content and thus its name).</p>
<p><strong>Design question: collisions</strong>. The state declaration says that each text maps to <em>one</em> address; that each address is mapped to by at most one (<em>lone</em>) text (asserting that collisions never happen). The mapping from text to address is <em>static</em>, so the address of a text cannot change. (Strictly speaking, the semantics of <em>static</em> might allow a text to be assigned an address, be forgotten, and then be assigned a different address. This might model a change of hash algorithm.)</p>
<p><strong>Design question: content type</strong>. I’m assuming for now that the contents are text, since this is easily compatible with the <em>Textnote</em> concept introduced before. Obviously content addressing could apply to a lower level representation and could handle other media types uniformly.</p>
<p><strong>Design question: indexing</strong>. The concept assumes some kind of index that comprises the state; at the moment, I’m not concerned with how this index might be localized, but will just assume it’s available globally. Given this, the role of the <em>forget</em> action isn’t clear.</p>
<p><strong>Design question: notes with same content</strong>. Anticipating the concept composition, I’m wondering what will happen if you save a buffer whose text content is the same as that of an existing note. I suppose what will happen is that no new note will be created, and instead the new shorthand name that you provide for the note will be bound to the existing note (in addition to any existing shorthand names). There’s a slight snag here because the <em>Textnote</em> concept says a new note is create on save, but it won’t be true in this case.</p>
<p>In Noosphere, notebooks are named by public keys. The purpose of this, presumably, is to avoid having a global directory mapping principals or notebooks to public keys: instead they just carry their public keys in their names.</p>
<pre><code>concept PublicKeyName [Principal]
purpose simplify key distribution
principle
state
  public, private: Principal one static -&gt; one static Key
actions
  generate (p: Principal, out pr, pu: Key)
    // generate new key pair for principal
  find (k: Key, out p: Principal)
    // return principal with public key k
  sign (t: Text, p: Principal, out s: Text)
    // sign text t with private key of p
  check (t: Text, p: Principal, s: Text, out valid: Bool)
  // with public key of p check signature s matches t
</code></pre>
<p><strong>Technical issue</strong>. Because concepts express state so abstractly (as relations), the difference between the key/principal relationship being in a global table and being carried by (a representation of) the principal itself isn’t made. This is a bit weird. For now, I’m not sure how to express the fact that the key is a name, except to provide an action to find a principal given a key, which is the quintessential naming lookup (and would presumably be missing in a key directory).</p>
<p><strong>Design question</strong>. I’ve declared the key/principal relations to be static in both directions, which means that (a) you can’t assign a new key to an existing principal, and (b) you can’t assign a new principal to an existing key (even its principal no longer exists). If not, Noosphere would break because references to notebooks would change in meaning over time. Notebook owners will have to make sure they run key generation just once and look after their private keys carefully!</p>
<p>Content addressable names and public key names are not mnemonic, so Noosphere introduces user-defined shorthands:</p>
<pre><code>concept Shorthand [Context, Object]
state
  resolve: Context, Short -&gt; one Object
actions
  createContext (out c: Context)
    // create new context for resolving shorthands
  deleteContext (c: Context)
    // remove context and all its shorthands
  createShorthand (c: Context, o: Object, out s: Short)
    // store new shorthand for object o in context c
  deleteShorthand (c: Context, s: Short)
    // remove shorthand s from context c
  lookup (c: Context, s: Short, out o: Object)
     // remove shorthand s from context c
</code></pre>
<p><strong>Design issue: uniqueness</strong>. In a given context, a shorthand must name a unique object but the same shorthand can name different objects in different contexts. Shorthands are not canonical: the same object can have multiple shorthand names, even in the same context.</p>
<p><strong>Design issue: mutability</strong>. The shorthand mapping is not static: a shorthand can name different objects at different times. In fact, this will be essential in Noosphere, since this will allow a shorthand to refer to the latest version of a note.</p>
<p><strong>Technical issue: naming names</strong>. The target of a shorthand, represented by the type variable <em>Object</em>, may itself be a name in another naming concept.</p>
<p><strong>Technical issue: shorthand name type</strong>. The <em>Short</em> type is abstracted here, but will usually just be a text string.</p>
<p><strong>Technical issue: allocating contexts</strong>. The concept is generic in <em>Context</em>, anticipating the decision that a notebook will be a context. This means that some clever synchronization will be needed, so that a context doesn’t get allocated in two concepts at once.</p>
<p>Noosphere has a simple kind of versioning, in which notes can point to their prior versions. I’ll model that with a generic versioning concept:</p>
<pre><code>concept Version [Object]
  purpose access to and restoring of old versions
  principle
    // if you register p as previous version of o,
    // then you'll get p if you ask for o's previous
    register (o, p); getPrev (o, p') {p' = p}
  state
	  previous: Object -&gt; lone Object
  actions
    register (o, prev: Object)
	    // record that prev is previous version of o
    getPrev (o: Object, out prev: Object)
      // return previous version of o (it exists)
</code></pre>
<p><strong>Design issue: invariants</strong>. Each object can have at most one predecessor, but potentially any number of successors. Cycles aren’t permitted; in particular, an object can’t be its own previous version.</p>
<p><strong>Design issue: interaction with content addressing</strong>. Suppose I have a note N1 and create a new version N2, but N2 happens to have the same content as N0, which already has its own previous version. What happens now?</p>
<h2 id="composing-concepts">Composing concepts<a hidden class="anchor" aria-hidden="true" href="#composing-concepts">#</a></h2>
<p>Notebook [Textnote.Note]
Textnote
ContentAddress [??]
PublicKeyName [Principal]
Shorthand [Notebook.Book, Textnote.Note]
Shorthand [Notebook.Book, Notebook.Book]
Version [Textnote.Note]</p>
<p><strong>To resolve</strong>:</p>
<ul>
<li>saving to note when context matches existing note</li>
<li>allocating contexts</li>
</ul>
<p>To do</p>
<ul>
<li>add objects to content address</li>
</ul>
<p>Questions. Can the previous version belong to another notebook? Why must shorthand contexts be associated with notebooks?</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>

  </footer>
</article>
    </main>
    
<footer class="footer">


    <span>&copy; 2023 <a href="https://essenceofsoftware.com">Daniel Jackson</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
