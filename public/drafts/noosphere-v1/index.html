<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Noosphere concepts | The Essence of Software</title>
<meta name="keywords" content="">
<meta name="description" content="A Concept Exploration of Noosphere">
<meta name="author" content="Daniel Jackson">
<link rel="canonical" href="https://essenceofsoftware.com/drafts/noosphere-v1/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.10b46262efde62bfde2e6b990234776439b6b9ca49ab4575de4ef7087668077b.css" integrity="sha256-ELRiYu/eYr/eLmuZAjR3ZDm2ucpJq0V13k73CHZoB3s=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://essenceofsoftware.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://essenceofsoftware.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://essenceofsoftware.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://essenceofsoftware.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://essenceofsoftware.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-WRQ6HWW3ZW"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-WRQ6HWW3ZW', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="Noosphere concepts" />
<meta property="og:description" content="A Concept Exploration of Noosphere" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://essenceofsoftware.com/drafts/noosphere-v1/" /><meta property="og:image" content="https://essenceofsoftware.com/eos-twitter-card.png"/><meta property="article:section" content="drafts" />
<meta property="article:published_time" content="2023-05-09T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-05-09T00:00:00+00:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://essenceofsoftware.com/eos-twitter-card.png"/>

<meta name="twitter:title" content="Noosphere concepts"/>
<meta name="twitter:description" content="A Concept Exploration of Noosphere"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Drafts",
      "item": "https://essenceofsoftware.com/drafts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Noosphere concepts",
      "item": "https://essenceofsoftware.com/drafts/noosphere-v1/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Noosphere concepts",
  "name": "Noosphere concepts",
  "description": "A Concept Exploration of Noosphere",
  "keywords": [
    
  ],
  "articleBody": "Intro This is an attempt to apply the concept design framework of EOS to Gordon Brander’s Noosphere. Because I don’t understand Noosphere well, it will no doubt contain many errors, but it seemed like a fun and useful exercise, both as a test for concept design and perhaps also to offer a different perspective to the design of Noosphere itself.\nIdentifying concepts The first step is to identify a collection of concepts that together can reproduce Noosphere’s basic functionality. Rather than starting with the concepts that Noosphere highlights (notably the central Sphere concept), I’ve followed the strategy of identifying concepts bottom-up, trying to be as granular as possible, and whenever possible reusing existing concepts that are domain independent.\nAfter identifying a concept, I attempt to describe it using the standard EOS structure: a name, a purpose for the concept, an operational principle (an archetypal scenario explaining how it’s used), a state schema, and some actions.\nCrucially, concepts can be generic, defined over some type variable (given after the name) which is bound when the concept is instantiated in a given design context.\nThe most basic concept seems to be the concept of a Notebook that is little more than a collection of notes:\nconcept Notebook [Note] purpose manage collection of owned notes principle // if you create a notebook and add a note // the note belongs to the notebook. create(b); add(b, n) {n in b.notes} state notes: Book one -\u003e set Note actions create (out b: Book) // create new book b delete (b: Book) // delete book b and its notes add (b: Book, n: Note) // add note n to book b remove (b: Book, n: Note) // remove note n from book b Related concepts. Notebook is similar to Folder, although notebooks usually can’t be nested. In contrast to Label (used, eg, to organize messages in Gmail) and Collection (used to organize photos in Lightroom), a note usually cannot belong to more than one notebook.\nDesign question: sharing. Can notes be shared between users? The Notebook concept does not allow a note to be shared between notebooks. A single notebook could be owned by multiple users, however. We might add an Ownership concept later.\nDesign question: mutability. Notebooks are mutable, but the concept does not commit to whether notes themselves are. In most existing apps (such as Notion), notes are indeed mutable, but they won’t be in Noosphere.\nDesign question: genericity. The Notebook concept allows any type of note, but in practice this will be restricted to some standard media type (text, rich text, image, audio, movie, etc).\nDesign question: minimality. The boring operational principle suggests that maybe there may be more to a notebook than this. Am I missing something?\nNow we turn to the notes themselves, and for now consider only a concept for textual notes:\nconcept Textnote purpose provide editable notes with textual content principle // if you open a buffer, edit some text in it, // and save the buffer to a note, then the note // contains the text open(b); edit(b,t); save(b, n) {n.content = t} state content: Note -\u003e one static Text current: Buffer -\u003e one Text actions open (out b: Buffer) // create a new buffer with empty text content open (n: Note, out b: Buffer) // create new buffer with text content of existing note edit (b: Buffer, t: Text) // update content of buffer b to be t save (b: Buffer, out n: Note) // create new note with content matching current content of buffer close (b: Buffer) // discard buffer and association with current text Related concepts. Textnote is similar to the File concept in GitHub’s web interface: when you open and edit a file in a repo, you’re modifying a buffer which you can then commit to create a new version of the file.\nDesign question: mutability. This concept introduces a type Note of immutable notes. The concept attempts to define the basic functionality needed for creating immutable notes incrementally; the idea is to introduce a mutable Buffer type for editing, which produces immutable notes on saving.\nNoosphere uses the conventional concept of content-addressable storage for naming notes, which I’ll attempt to define in a concept:\nconcept ContentAddress [Object] purpose name objects by content principle // if you create an object, and later get an // object with the same address, it will // have the same content create(o, a); get(a, o') {o’.content = o.content} state address: Object -\u003e one static Address content: Object -\u003e one static Text actions create (o: Object, t: Text, out a: Address) // create object o with contents t and // compute a new address and store it get (a: Address, out o: Object) // return any object with address a forget (a: Address) // forget text associated with an address Design question: purpose. I am not sure how to express the purpose, that is what motivates this concept. It seems to be a combination of a naming scheme that works across storage sites (since an object implicitly carries its own name), and a kind of built-in authentication (since modifying of corrupting an object will change its content and thus its name).\nDesign question: copies. The concept makes explicit that there may be several objects that are copies of the same content and that therefore have the same name. The get action is undetermined by design: it doesn’t specify which object is returned when more than one with the right address is available.\nDesign question: immutability. Note that the address and content relations are immutable: the address is computed by a hash function that is assumed not to change, and the content is not permitted to change (since otherwise the address would no longer match the contents).\nDesign question: collisions. The operational principle actually relies on there being no hash collisions. This is a reasonable assumption in practice.\nDesign question: content type. I’m assuming for now that the contents are text, since this is compatible with the Textnote concept introduced before. Obviously, content addressing could apply to a lower level representation and could handle other media types uniformly.\nDesign question: indexing. The concept assumes some kind of index (or cache) that comprises the address component of the state; at the moment, I’m not concerned with how this index might be localized, but will just assume it’s always available. Given this, the role of the forget action isn’t clear.\nIn Noosphere, notebooks are named by public keys. The purpose of this, presumably, is to avoid having a global directory mapping principals or notebooks to public keys: instead they just carry their public keys in their names.\nconcept PublicKeyName [Principal] purpose simplify key distribution principle state public, private: Principal one static -\u003e one static Key actions generate (p: Principal, out pr, pu: Key) // generate new key pair for principal find (k: Key, out p: Principal) // return principal with public key k sign (t: Text, p: Principal, out s: Text) // sign text t with private key of p check (t: Text, p: Principal, s: Text, out valid: Bool) // with public key of p check signature s matches t Technical issue. Because concepts express state so abstractly (as relations), the difference between the key/principal relationship being in a global table and being carried by (a representation of) the principal itself isn’t made. This is a bit weird. For now, I’m not sure how to express the fact that the key is a name, except to provide an action to find a principal given a key, which is the quintessential naming lookup (and would presumably be missing in a key directory).\nDesign question. I’ve declared the key/principal relations to be static in both directions, which means that (a) you can’t assign a new key to an existing principal, and (b) you can’t assign a new principal to an existing key (even its principal no longer exists). If not, Noosphere would break because references to notebooks would change in meaning over time. Notebook owners will have to make sure they do key generation just once and save their private keys carefully!\nContent-addressable names and public-key names are not mnemonic, so Noosphere introduces user-defined shorthands:\nconcept Shorthand [Context, Object] purpose mnemonic, local naming of objects principle // if you bind a short to an object // you can then look it up with that short bind (c, o, s); lookup (c, s, o') {o = o'} state resolve: Context, Short -\u003e one Object actions bind (c: Context, o: Object, out s: Short) // set shorthand for o in context c to be s // remove bindings for existing objects named s in c unbind (c: Context, s: Short) // remove shorthand s from context c lookup (c: Context, s: Short, out o: Object) // return object with shorthand s in context c Design issue: uniqueness. In a given context, a shorthand must name a unique object but the same shorthand can name different objects in different contexts. Shorthands (unlike content addresses) are not canonical: the same object can have multiple shorthand names, even in the same context.\nDesign issue: mutability. The shorthand mapping is not static: a shorthand can name different objects at different times. In fact, this will be essential in Noosphere, since this will allow a shorthand to refer to the latest version of a note.\nTechnical issue: naming names. The target of a shorthand, represented by the type variable Object, may itself be a name in another naming concept.\nTechnical issue: shorthand name type. The Short will usually just be a text string, but since no properties of the name beyond equality are assumed, the type is abstracted here.\nNoosphere has a simple kind of versioning, in which notes can point to their prior versions. I’ll model that with a generic versioning concept:\nconcept Version [Object] purpose access to and restoring of old versions principle // if you register p as previous version of o, // you'll get p if you ask for o's previous version register (o, p); getPrev (o, p') {p' = p} state previous: Object -\u003e lone Object actions register (o, prev: Object) // record that prev is previous version of o getPrev (o: Object, out prev: Object) // return previous version of o (it exists) Design issue: invariants. Each object can have at most one predecessor, but potentially any number of successors. Cycles aren’t permitted; in particular, an object can’t be its own previous version.\nComposing concepts Now we can assemble the concepts by composition. The first step is to instantiate the concepts, binding their type parameters to domain-specific types:\napp Noosphere include Textnote Notebook [Textnote.Note] ContentAddress [Textnote.Note] PublicKeyName [Notebook.Book] Shorthand [Notebook.Book, Textnote.Note] Shorthand [Notebook.Book, Notebook.Book] Version [Textnote.Note] These inclusions say that the text notes of the Textnote concept comprise the notes of the Notebook concept and the objects of the ContentAddress concept. The PublicKeyName concept is applied to the books of the Notebook concept: that is, each notebook has its own public key.\nThe Shorthand concept is instantiated twice, to introduce shorthands for notes and for books. In both cases, the context is a notebook, the idea being that each notebook interprets the names within its notes. If a note in my notebook includes the name @gordon/composability, this will be resolved by finding the public key associated with @gordon, and then obtaining within the notebook with that public-key name the note whose content-address is associated with composability.\nThe second step is to synchronize the actions of the concepts. Let’s focus on a few of the more interesting ones.\nHere’s an attempt at explaining what happens when a note is saved:\nsync save_note ( b: Notebook.Book, x: Textnote.Buffer, s: Short, prev: Textnote.Note, out n: Textnote.Note, out t: Text, out a: ContentAddress.Address) when t = Textnote.current[x] and prev in Notebook.notes[b] Textnote.save (x, n) Notebook.add (b, n) ContentAddress.create (n, t, a) Shorthand.bind (b, a, s) Version.register (n, prev) The arguments of the action include the book to which the note is being saved; the buffer being edited, a shorthand name being assigned to the new note, and the identity of the previous version of the note.\nWhen the note is saved, the following actions occur in each of the concepts:\nIn Textnote: the content of the buffer is saved to a note; In Notebook: the resulting note is added to the book; In ContentAddress: a new address is computed for the note; In Shorthand: the shorthand is bound to the new note (and, if used for previous versions, unbound); In Version, the new note is registered as the new version of the previous note. Design question: latest version naming. Assuming that the user of this notebook reuses the same shorthand name for all versions of this note, an external user requesting a note with a given shorthand name will now acquire a copy of the new note. This seems right.\nDesign question: content addresses not distinct. If the text in the buffer happens to be the same as the text in an existing note in this notebook, the new note that is created will have the same content address as the existing note. Two distinct notes (with different version histories) will have the same content address name. Presumably this isn’t a problem, since a request for a note from an external user will provide only its content, and will not reveal the identity of the note or its version history. That is, content addresses aren’t canonical for the local notes in a notebook, but only for the cache of notes obtained externally.\nDesign question: cross-notebook versioning. The precondition requires the previous version of the note to belong to the same notebook. The alternative seems like trouble, because version tracking requires notebook identities, which are hidden outside a notebook.\nDesign question: unstable shorthands. We haven’t specified the relevant syncs for this, but I’m assuming that a notebook does not hold, in its shorthand context, the bindings for external notes. This means that the meaning of a reference appearing in a note in Alice’s notebook to a note in Bob’s notebook may change when Bob rebinds the shorthand. If Alice wants to avoid this, presumably she could reference the note by its content address (you could imagine an action that lets you specify the current shorthand for a link but then inserts the relevant content address). Another possibility would be that a notebook has a shorthand context not only for external notebooks, but also for notes in those notebooks. Then shorthands would be stable but would not get automatic version updates.\nDesign question: local resolving of shorthands. When a reference in a note obtained from an external notebook is resolved, is it cached locally? Presumably this means that different clients in a P2P network will disagree on the meaning of a shorthand?\nDesign question: notebook as shorthand context. It is not necessary that the notebook be the context for shorthands; there could be multiple contexts per notebook, or multiple notebooks per context. The notion of a “sphere” that combines notebook and shorthand context seems like the right default.\nReflections This exploration suggests some opportunities and issues for concept design (CD):\nDecoupling. CD seems to offer a nice way to decouple the elements of an intricate design like Noosphere, and to identify and incorporate the relevant preexisting concepts. Catalog. Defining the preexisting concepts was pretty hard, reflecting partly my own lack of knowledge, but also the subtlety of some of these concepts. This whole exercise makes it clear to me how valuable a catalog would be, so that a designer could just look up the concepts, learn about them, incorporate the right variants, and not have to figure them out. More and less well-documented concepts. Some of the concepts, such as ContentAddress, correspond to technology ideas that have been extensively described but not formulated as pithy concepts. Others correspond to ideas that must be well known to some but haven’t been widely articulated. Textnote, for example, tries to represent a simple scheme for an editing process that gives the appearance of a mutable document but produces a sequence of immutable instances. (This suggests I should probably have focused the concept purely on that, factored out the textual aspect and made it generic.) Synergy. Some of the compositions are probably resulting in design synergies that it would be good to explore. Using the Sphere for bounding the notebook, providing a context for shorthands, and carrying a public key is presumably synergistic in ways it would be good to figure out. Maybe public key naming should be described as a synergistic composition of a generic naming scheme and a naming-independent PKI concept. Allocation. Deciding when to have actions for allocation of objects is tricky, and I wanted to have concepts that could both allocate their own objects and compose with other concepts that would do the allocation instead. (This issue arose for allocating contexts in Shorthand: originally I had an allocation action in the concept itself, but then wasn’t sure how to treat the notebook, which is allocated elsewhere, as a context.) Perhaps the solution to this is to find a different way to model allocation of objects in concepts, maybe with some simple implicit default, so that it doesn’t need to be considered in most concept definitions. ",
  "wordCount" : "2875",
  "inLanguage": "en",
  "datePublished": "2023-05-09T00:00:00Z",
  "dateModified": "2023-05-09T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Daniel Jackson"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://essenceofsoftware.com/drafts/noosphere-v1/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "The Essence of Software",
    "logo": {
      "@type": "ImageObject",
      "url": "https://essenceofsoftware.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://essenceofsoftware.com" accesskey="h" title="The Essence of Software (Alt + H)">The Essence of Software</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://essenceofsoftware.com/ask/" title="FAQ">
                    <span>FAQ</span>
                </a>
            </li>
            <li>
                <a href="https://essenceofsoftware.com/buy/" title="Buy">
                    <span>Buy</span>
                </a>
            </li>
            <li>
                <a href="https://essenceofsoftware.com/reviews/" title="Reviews">
                    <span>Reviews</span>
                </a>
            </li>
            <li>
                <a href="https://essenceofsoftware.com/author/" title="Author">
                    <span>Author</span>
                </a>
            </li>
            <li>
                <a href="https://essenceofsoftware.com/posts/" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="https://essenceofsoftware.com/tutorials/" title="Tutorials">
                    <span>Tutorials</span>
                </a>
            </li>
            <li>
                <a href="https://essenceofsoftware.com/studies/" title="Case Studies">
                    <span>Case Studies</span>
                </a>
            </li>
            <li>
                <a href="https://essenceofsoftware.com/subscribe/" title="Subscribe">
                    <span>Subscribe</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Noosphere concepts
    </h1>
    <div class="post-description">
      A Concept Exploration of Noosphere
    </div>
    <div class="post-meta"><span title='2023-05-09 00:00:00 +0000 UTC'>May 9, 2023</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;Daniel Jackson&nbsp;|&nbsp;<a href="https://forum.essenceofsoftware.com" rel="noopener noreferrer" target="_blank">Comments</a>

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#intro" aria-label="Intro">Intro</a></li>
                <li>
                    <a href="#identifying-concepts" aria-label="Identifying concepts">Identifying concepts</a></li>
                <li>
                    <a href="#composing-concepts" aria-label="Composing concepts">Composing concepts</a></li>
                <li>
                    <a href="#reflections" aria-label="Reflections">Reflections</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="intro">Intro<a hidden class="anchor" aria-hidden="true" href="#intro">#</a></h2>
<p>This is an attempt to apply the concept design framework of <a href="https://essenceofsoftware.com">EOS</a> to Gordon Brander’s <a href="https://subconscious.substack.com/p/noosphere-a-protocol-for-thought">Noosphere</a>. Because I don’t understand Noosphere well, it will no doubt contain many errors, but it seemed like a fun and useful exercise, both as a test for concept design and perhaps also to offer a different perspective to the design of Noosphere itself.</p>
<h2 id="identifying-concepts">Identifying concepts<a hidden class="anchor" aria-hidden="true" href="#identifying-concepts">#</a></h2>
<p>The first step is to identify a collection of concepts that together can reproduce Noosphere’s basic functionality. Rather than starting with the concepts that Noosphere highlights (notably the central <em>Sphere</em> concept), I’ve followed the strategy of identifying concepts bottom-up, trying to be as granular as possible, and whenever possible reusing existing concepts that are domain independent.</p>
<p>After identifying a concept, I attempt to describe it using the standard EOS <a href="https://essenceofsoftware.com/posts/distillation/#a-structure-for-describing-concepts">structure</a>: a <em>name</em>, a <em>purpose</em> for the concept, an <em>operational principle</em> (an archetypal scenario explaining how it’s used), a <em>state</em> schema, and some <em>actions</em>.</p>
<p>Crucially, concepts can be generic, defined over some type variable (given after the name) which is bound when the concept is instantiated in a given design context.</p>
<p>The most basic concept seems to be the concept of a <em>Notebook</em> that is little more than a collection of notes:</p>
<pre><code>concept Notebook [Note]
purpose
  manage collection of owned notes
principle
  // if you create a notebook and add a note
  // the note belongs to the notebook.
  create(b); add(b, n) {n in b.notes}
state
  notes: Book one -&gt; set Note
actions
  create (out b: Book)
    // create new book b
  delete (b: Book)
    // delete book b and its notes
  add (b: Book, n: Note)
    // add note n to book b
  remove (b: Book, n: Note)
    // remove note n from book b
</code></pre>
<p><strong>Related concepts</strong>. <em>Notebook</em> is similar to <em>Folder</em>, although notebooks usually can’t be nested. In contrast to <em>Label</em> (used, eg, to organize messages in Gmail) and <em>Collection</em> (used to organize photos in Lightroom), a note usually cannot belong to more than one notebook.</p>
<p><strong>Design question: sharing</strong>. Can notes be shared between users? The <em>Notebook</em> concept does not allow a note to be shared between notebooks. A single notebook could be owned by multiple users, however. We might add an <em>Ownership</em> concept later.</p>
<p><strong>Design question: mutability</strong>. Notebooks are mutable, but the concept does not commit to whether notes themselves are. In most existing apps (such as Notion), notes are indeed mutable, but they won’t be in Noosphere.</p>
<p><strong>Design question: genericity</strong>. The <em>Notebook</em> concept allows any type of note, but in practice this will be restricted to some standard media type (text, rich text, image, audio, movie, etc).</p>
<p><strong>Design question: minimality</strong>. The boring operational principle suggests that maybe there may be more to a notebook than this. Am I missing something?</p>
<p>Now we turn to the notes themselves, and for now consider only a concept for textual notes:</p>
<pre><code>concept Textnote
purpose provide editable notes with textual content
principle
  // if you open a buffer, edit some text in it,
  // and save the buffer to a note, then the note
  // contains the text
  open(b); edit(b,t); save(b, n) {n.content = t}
state
  content: Note -&gt; one static Text
  current: Buffer -&gt; one Text
actions
  open (out b: Buffer)
    // create a new buffer with empty text content
  open (n: Note, out b: Buffer)
    // create new buffer with text content of existing note
  edit (b: Buffer, t: Text)
    // update content of buffer b to be t
  save (b: Buffer, out n: Note)
    // create new note with content matching current content of buffer
  close (b: Buffer)
    // discard buffer and association with current text
</code></pre>
<p><strong>Related concepts</strong>. <em>Textnote</em> is similar to the <em>File</em> concept in GitHub’s web interface: when you open and edit a file in a repo, you’re modifying a buffer which you can then commit to create a new version of the file.</p>
<p><strong>Design question: mutability</strong>. This concept introduces a type <em>Note</em> of immutable notes. The concept attempts to define the basic functionality needed for creating immutable notes incrementally; the idea is to introduce a mutable <em>Buffer</em> type for editing, which produces immutable notes on saving.</p>
<p>Noosphere uses the conventional concept of content-addressable storage for naming notes, which I’ll attempt to define in a concept:</p>
<pre><code>concept ContentAddress [Object]
purpose name objects by content
principle
  // if you create an object, and later get an 
  // object with the same address, it will 
  // have the same content
  create(o, a); get(a, o') {o’.content = o.content}
state
  address: Object -&gt; one static Address
  content: Object -&gt; one static Text
actions
  create (o: Object, t: Text, out a: Address)
    // create object o with contents t and
    // compute a new address and store it
  get (a: Address, out o: Object)
    // return any object with address a
  forget (a: Address)
    // forget text associated with an address
</code></pre>
<p><strong>Design question: purpose</strong>. I am not sure how to express the purpose, that is what motivates this concept. It seems to be a combination of a naming scheme that works across storage sites (since an object implicitly carries its own name), and a kind of built-in authentication (since modifying of corrupting an object will change its content and thus its name).</p>
<p><strong>Design question: copies</strong>. The concept makes explicit that there may be several objects that are copies of the same content and that therefore have the same name. The <em>get</em> action is undetermined by design: it doesn’t specify which object is returned when more than one with the right address is available.</p>
<p><strong>Design question: immutability</strong>. Note that the <em>address</em> and <em>content</em> relations are immutable: the address is computed by a hash function that is assumed not to change, and the content is not permitted to change (since otherwise the address would no longer match the contents).</p>
<p><strong>Design question: collisions</strong>. The operational principle actually relies on there being no hash collisions. This is a reasonable assumption in practice.</p>
<p><strong>Design question: content type</strong>. I’m assuming for now that the contents are text, since this is compatible with the <em>Textnote</em> concept introduced before. Obviously, content addressing could apply to a lower level representation and could handle other media types uniformly.</p>
<p><strong>Design question: indexing</strong>. The concept assumes some kind of index (or cache) that comprises the <em>address</em> component of the state; at the moment, I’m not concerned with how this index might be localized, but will just assume it’s always available. Given this, the role of the <em>forget</em> action isn’t clear.</p>
<p>In Noosphere, notebooks are named by public keys. The purpose of this, presumably, is to avoid having a global directory mapping principals or notebooks to public keys: instead they just carry their public keys in their names.</p>
<pre><code>concept PublicKeyName [Principal]
purpose simplify key distribution
principle
state
  public, private: Principal one static -&gt; one static Key
actions
  generate (p: Principal, out pr, pu: Key)
    // generate new key pair for principal
  find (k: Key, out p: Principal)
    // return principal with public key k
  sign (t: Text, p: Principal, out s: Text)
    // sign text t with private key of p
  check (t: Text, p: Principal, s: Text, out valid: Bool)
  // with public key of p check signature s matches t
</code></pre>
<p><strong>Technical issue</strong>. Because concepts express state so abstractly (as relations), the difference between the key/principal relationship being in a global table and being carried by (a representation of) the principal itself isn’t made. This is a bit weird. For now, I’m not sure how to express the fact that the key is a name, except to provide an action to find a principal given a key, which is the quintessential naming lookup (and would presumably be missing in a key directory).</p>
<p><strong>Design question</strong>. I’ve declared the key/principal relations to be static in both directions, which means that (a) you can’t assign a new key to an existing principal, and (b) you can’t assign a new principal to an existing key (even its principal no longer exists). If not, Noosphere would break because references to notebooks would change in meaning over time. Notebook owners will have to make sure they do key generation just once and save their private keys carefully!</p>
<p>Content-addressable names and public-key names are not mnemonic, so Noosphere introduces user-defined shorthands:</p>
<pre><code>concept Shorthand [Context, Object]
purpose mnemonic, local naming of objects
principle
  // if you bind a short to an object
  // you can then look it up with that short
  bind (c, o, s); lookup (c, s, o') {o = o'}
state
  resolve: Context, Short -&gt; one Object
actions
  bind (c: Context, o: Object, out s: Short)
    // set shorthand for o in context c to be s
    // remove bindings for existing objects named s in c
  unbind (c: Context, s: Short)
    // remove shorthand s from context c
  lookup (c: Context, s: Short, out o: Object)
    // return object with shorthand s in context c
</code></pre>
<p><strong>Design issue: uniqueness</strong>. In a given context, a shorthand must name a unique object but the same shorthand can name different objects in different contexts. Shorthands (unlike content addresses) are not canonical: the same object can have multiple shorthand names, even in the same context.</p>
<p><strong>Design issue: mutability</strong>. The shorthand mapping is not static: a shorthand can name different objects at different times. In fact, this will be essential in Noosphere, since this will allow a shorthand to refer to the latest version of a note.</p>
<p><strong>Technical issue: naming names</strong>. The target of a shorthand, represented by the type variable <em>Object</em>, may itself be a name in another naming concept.</p>
<p><strong>Technical issue: shorthand name type</strong>. The <em>Short</em> will usually just be a text string, but since no properties of the name beyond equality are assumed, the type is abstracted here.</p>
<p>Noosphere has a simple kind of versioning, in which notes can point to their prior versions. I’ll model that with a generic versioning concept:</p>
<pre><code>concept Version [Object]
  purpose access to and restoring of old versions
  principle
    // if you register p as previous version of o,
    // you'll get p if you ask for o's previous version
    register (o, p); getPrev (o, p') {p' = p}
  state
	  previous: Object -&gt; lone Object
  actions
    register (o, prev: Object)
	    // record that prev is previous version of o
    getPrev (o: Object, out prev: Object)
      // return previous version of o (it exists)
</code></pre>
<p><strong>Design issue: invariants</strong>. Each object can have at most one predecessor, but potentially any number of successors. Cycles aren’t permitted; in particular, an object can’t be its own previous version.</p>
<h2 id="composing-concepts">Composing concepts<a hidden class="anchor" aria-hidden="true" href="#composing-concepts">#</a></h2>
<p>Now we can assemble the concepts by composition. The first step is to instantiate the concepts, binding their type parameters to domain-specific types:</p>
<pre><code>app Noosphere
include
	Textnote
	Notebook [Textnote.Note]
	ContentAddress [Textnote.Note]
	PublicKeyName [Notebook.Book]
	Shorthand [Notebook.Book, Textnote.Note]
	Shorthand [Notebook.Book, Notebook.Book]
	Version [Textnote.Note]
</code></pre>
<p>These inclusions say that the text notes of the <em>Textnote</em> concept comprise the notes of the <em>Notebook</em> concept and the objects of the <em>ContentAddress</em> concept. The <em>PublicKeyName</em> concept is applied to the books of the <em>Notebook</em> concept: that is, each notebook has its own public key.</p>
<p>The <em>Shorthand</em> concept is instantiated twice, to introduce shorthands for notes and for books. In both cases, the context is a notebook, the idea being that each notebook interprets the names within its notes. If a note in my notebook includes the name <em>@gordon/composability</em>, this will be resolved by finding the public key associated with <em>@gordon</em>, and then obtaining within the notebook with that public-key name the note whose content-address is associated with <em>composability</em>.</p>
<p>The second step is to synchronize the actions of the concepts. Let’s focus on a few of the more interesting ones.</p>
<p>Here’s an attempt at explaining what happens when a note is saved:</p>
<pre><code>sync save_note (
	b: Notebook.Book,
	x: Textnote.Buffer,
	s: Short,
	prev: Textnote.Note,
	out n: Textnote.Note,
	out t: Text,
	out a: ContentAddress.Address)
	
	when t = Textnote.current[x]
	  and prev in Notebook.notes[b]
	Textnote.save (x, n)
	Notebook.add (b, n)
	ContentAddress.create (n, t, a)
	Shorthand.bind (b, a, s)
	Version.register (n, prev)
</code></pre>
<p>The arguments of the action include the book to which the note is being saved; the buffer being edited, a shorthand name being assigned to the new note, and the identity of the previous version of the note.</p>
<p>When the note is saved, the following actions occur in each of the concepts:</p>
<ul>
<li>In <em>Textnote</em>: the content of the buffer is saved to a note;</li>
<li>In <em>Notebook</em>: the resulting note is added to the book;</li>
<li>In <em>ContentAddress</em>: a new address is computed for the note;</li>
<li>In <em>Shorthand</em>: the shorthand is bound to the new note (and, if used for previous versions, unbound);</li>
<li>In <em>Version</em>, the new note is registered as the new version of the previous note.</li>
</ul>
<p><strong>Design question: latest version naming</strong>. Assuming that the user of this notebook reuses the same shorthand name for all versions of this note, an external user requesting a note with a given shorthand name will now acquire a copy of the new note. This seems right.</p>
<p><strong>Design question: content addresses not distinct</strong>. If the text in the buffer happens to be the same as the text in an existing note in this notebook, the new note that is created will have the same content address as the existing note. Two distinct notes (with different version histories) will have the same content address name. Presumably this isn’t a problem, since a request for a note from an external user will provide only its content, and will not reveal the identity of the note or its version history. That is, content addresses aren’t canonical for the local notes in a notebook, but only for the cache of notes obtained externally.</p>
<p><strong>Design question: cross-notebook versioning</strong>. The precondition requires the previous version of the note to belong to the same notebook. The alternative seems like trouble, because version tracking requires notebook identities, which are hidden outside a notebook.</p>
<p><strong>Design question: unstable shorthands</strong>. We haven’t specified the relevant syncs for this, but I’m assuming that a notebook does not hold, in its shorthand context, the bindings for external notes. This means that the meaning of a reference appearing in a note in Alice’s notebook to a note in Bob’s notebook may change when Bob rebinds the shorthand. If Alice wants to avoid this, presumably she could reference the note by its content address (you could imagine an action that lets you specify the current shorthand for a link but then inserts the relevant content address). Another possibility would be that a notebook has a shorthand context not only for external notebooks, but also for notes in those notebooks. Then shorthands would be stable but would not get automatic version updates.</p>
<p><strong>Design question: local resolving of shorthands</strong>. When a reference in a note obtained from an external notebook is resolved, is it cached locally? Presumably this means that different clients in a P2P network will disagree on the meaning of a shorthand?</p>
<p><strong>Design question: notebook as shorthand context</strong>. It is not necessary that the notebook be the context for shorthands; there could be multiple contexts per notebook, or multiple notebooks per context. The notion of a “sphere” that combines notebook and shorthand context seems like the right default.</p>
<h2 id="reflections">Reflections<a hidden class="anchor" aria-hidden="true" href="#reflections">#</a></h2>
<p>This exploration suggests some opportunities and issues for concept design (CD):</p>
<ul>
<li><strong>Decoupling.</strong> CD seems to offer a nice way to decouple the elements of an intricate design like Noosphere, and to identify and incorporate the relevant preexisting concepts.</li>
<li><strong>Catalog</strong>. Defining the preexisting concepts was pretty hard, reflecting partly my own lack of knowledge, but also the subtlety of some of these concepts. This whole exercise makes it clear to me how valuable a catalog would be, so that a designer could just look up the concepts, learn about them, incorporate the right variants, and not have to figure them out.</li>
<li><strong>More and less well-documented concepts</strong>. Some of the concepts, such as <em>ContentAddress</em>, correspond to technology ideas that have been extensively described but not formulated as pithy concepts. Others correspond to ideas that must be well known to some but haven’t been widely articulated. <em>Textnote</em>, for example, tries to represent a simple scheme for an editing process that gives the appearance of a mutable document but produces a sequence of immutable instances. (This suggests I should probably have focused the concept purely on that, factored out the textual aspect and made it generic.)</li>
<li><strong>Synergy</strong>. Some of the compositions are probably resulting in <a href="https://essenceofsoftware.com/posts/distillation/#concept-synergy">design synergies</a> that it would be good to explore. Using the Sphere for bounding the notebook, providing a context for shorthands, and carrying a public key is presumably synergistic in ways it would be good to figure out. Maybe public key naming should be described as a synergistic composition of a generic naming scheme and a naming-independent PKI concept.</li>
<li><strong>Allocation</strong>. Deciding when to have actions for allocation of objects is tricky, and I wanted to have concepts that could both allocate their own objects and compose with other concepts that would do the allocation instead. (This issue arose for allocating contexts in <em>Shorthand</em>: originally I had an allocation action in the concept itself, but then wasn’t sure how to treat the notebook, which is allocated elsewhere, as a context.) Perhaps the solution to this is to find a different way to model allocation of objects in concepts, maybe with some simple implicit default, so that it doesn’t need to be considered in most concept definitions.</li>
<li></li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>

  </footer>
</article>
    </main>
    
<footer class="footer">


    <span>&copy; 2025 <a href="https://essenceofsoftware.com">Daniel Jackson</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
