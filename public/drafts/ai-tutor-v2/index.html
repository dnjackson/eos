<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Notes on design of a GPT-powered tutor | The Essence of Software</title>
<meta name="keywords" content="">
<meta name="description" content="Notes on design of a GPT-powered tutor">
<meta name="author" content="Daniel Jackson">
<link rel="canonical" href="https://essenceofsoftware.com/drafts/ai-tutor-v2/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.975c213687e3725078fea4c6a99c54b6db419fd121c9e4e30c596e892a20471d.css" integrity="sha256-l1whNofjclB4/qTGqZxUtttBn9EhyeTjDFluiSogRx0=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://essenceofsoftware.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://essenceofsoftware.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://essenceofsoftware.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://essenceofsoftware.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://essenceofsoftware.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-WRQ6HWW3ZW"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-WRQ6HWW3ZW', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="Notes on design of a GPT-powered tutor" />
<meta property="og:description" content="Notes on design of a GPT-powered tutor" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://essenceofsoftware.com/drafts/ai-tutor-v2/" /><meta property="og:image" content="https://essenceofsoftware.com/eos-twitter-card.png"/><meta property="article:section" content="drafts" />
<meta property="article:published_time" content="2023-05-11T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-05-11T00:00:00+00:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://essenceofsoftware.com/eos-twitter-card.png"/>

<meta name="twitter:title" content="Notes on design of a GPT-powered tutor"/>
<meta name="twitter:description" content="Notes on design of a GPT-powered tutor"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Drafts",
      "item": "https://essenceofsoftware.com/drafts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Notes on design of a GPT-powered tutor",
      "item": "https://essenceofsoftware.com/drafts/ai-tutor-v2/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Notes on design of a GPT-powered tutor",
  "name": "Notes on design of a GPT-powered tutor",
  "description": "Notes on design of a GPT-powered tutor",
  "keywords": [
    
  ],
  "articleBody": "Goals and Principles These notes are intended to contribute to the design of a tutor based on GPT that Geoffrey is building for use in Software Studio this fall.\nSome of the goals of building and deploying the tutor are:\nTo get some initial experience using GPT-like tools in education; To help students learn concept design; To gather data both about students’ learning of concept design and about the performance of the AI tutor; To refine the pedagogy around concept design. Some design principles of the tutor are:\nTo make the simplest thing that works; While serving the needs of concept design, to make the tutor as general as possible so that it can be applied in other domains; To reduce barrier to usage by students; To make it easy for class staff to change the materials and exercises; To implement using the class tech stack–Node/Express, Vue (or React if that’s easier for Geoffrey)–so the tutor can be used as an exemplar for students and also easily modified by staff; Identifying concepts The central concept captures the protocol of interacting with tools like GPT:\nconcept ChatBot purpose interact with AI agent principle prompt (t0); ask (t1); respond (t2); ... state prompt: lone Text questions, answers: seq Text actions prompt (t: Text) // initialize the chatbot with a prompt ask (t: Text) // user enters text respond (t: Text) // bot responds The prompt will turn out to be a concatenation of distinct components, such as a general tactic for the bot to follow; a pedagogical context for the exercise at hand; and the starting seed for the exercise itself (eg, “ask the user to do X”).\nThe student will work in a mutable buffer, generating a sequence of immutable texts:\nconcept Buffer purpose create immutable text with mutable buffer principle // if you open buffer and edit it, // saving produces last content open (t); edit (t'); save (ts) {ts = t'} state content: Text actions open (t: Text) // reset buffer contents to t edit (t: Text) // edit buffer content to be t save (out t: Text) // save contents of buffer The save action is intended to be sync’d with another concept; this factors out the means by which the text is saved and where it’s saved to.\nConcept design theory aside. This concept might seem so simple that its functionality should be absorbed into another concept (eg, Drill, below). But this would be a mistake. First, it embodies distinct and complex functionality–a complete text editor. The edit action represents very abstractly and generally all possible edits. Second, by separating the concept out we’re able to lift it (that is, create an indexed collection of instances without having to pollute any concept with a spurious index type).\nThe chatbot is fueled by a repository of advice, which I’ll model as a concept that offers advice on various topics:\nconcept Advice [Topic] purpose manage repo of advice principle // create topic, add advice, then getting // advice will return all advice added to that // topic newTopic (n, t); addAdvice (t, a1)... addAdvice (t, aN); get (t, a') {a' = a1 + ... + aN} state advices: Topic -\u003e set Text name: Topic lone -\u003e one Text actions newTopic (name: Text, out t: Topic) addAdvice (t: Topic, advice: Text) getAdvice (t: Topic, out advices: set Text) Concept design theory aside. Another concept that might seem too simple to represent. In this case, the behavior is indeed very simple, but the concept is factored out because it represents very distinct and domain-dependent functionality, and represents a significant part of the tutor. I’ve included an action getAdvice to help reify the operational principle even though the state is visible and observer actions aren’t generally needed. Could this concept be made more similar to one that already exists, such as a Q\u0026A concept of the sort you might use to model StackOverflow etc? In the AI tutor setting, the advice will be given to the chatbot, not the student, but this should be irrelevant in the design of the concept.\nThe pedagogical content is organized as a collection of exercises with multiple parts; the parts are associated with competencies (which will be the topics for advice).\nconcept Exercise purpose maintain and offer structured exercises principle // admin creates exercise with parts // when student selects part, they get // the relevant descriptions newExercise(te, e); newPart (e, tp, c, p); getPart (e, p, t', c') {t' = te^tp, c' = c} state parts: Exercise one -\u003e set Part competency: Part -\u003e one Competency description: Exercise + Part -\u003e one Text actions newCompetency (out c: Competency) newExercise (t: Text, out e: Exercise) newPart (e: Exercise, t: Text, c: Competency, out p: Part) getExercise (e: Exercise, out t: Text) getPart (e: Exercise, p: Part, out t: Text, out c: Competency) // when student selects a part of an exercise, // they're given a description that combines // the description of the exercise with the // description of the part (and the competency // they'll acquire) Notes:\nBoth exercises and their parts have descriptions Competency associated only with parts and not whole exercises. This will mean we can’t associate advice with exercises as a whole. Perhaps advice common to all parts is just included for those parts? Parts are not shared between exercises Considered including student behavior in this concept to make it richer but then decided it was more important to factor it out so that the student behavior concept could be lifted over students (that is, each student behavior being independent) selectexercise was added so that it could be synchronized with the resetting of the buffer as the student begins a new exercise. Competencies will presumably have textual names, but treating them abstractly in the concept. Concept for student behavior:\nconcept Drill [Task] purpose store incremental student work on structured task principle // if you select a task and one of its subtasks // and then submit a solution, it's recorded // appropriately selectTask (t); selectSubTask (t, t'); submit (s) {t' in t.subtasks and t.solution = s} state subtasks: Task one -\u003e set Task solution: Task -\u003e lone Text current: lone Task actions selectTask (t: Task) // set current to t selectSubTask (super, sub: Task) // set current to sub // ensure sub a subtask of super submit (t: Text) // current.solution := t Notes:\nDecided to make this cursor-based; not sure this is a good idea, but seems useful to have this state somewhere in the app. OP is not very satisfying but at least suggests how concept is used. An important design issue. For simplicity, this design assumes that student work is saved only for subtasks (which will correspond to parts of exercises). There is no separate storage of whole exercise solutions. Instead, the text of an exercise solution is derived from the texts of the solutions of the parts. The student may be shown a coherent block of text representing their solution to the whole exercise but will not be able to edit it: only edits to solutions to parts are allowed. The Drill concept maintains the fragmentary solutions; the app can display a solution to an entire exercise by combining state from Exercise and Drill.\nA concept is needed to manage student sessions and provide access to students to the work they have done:\nconcept Session purpose maintain persistent identities of clients principle // if you open a session on a client and then // get the session at the client before closing, // you'll get the session that was created on open open (c, s); getSession (c, s') {s' = s} state session: Client -\u003e one Session actions open (c: Client, out s: Session) // create new session on client getSession (c: Client, out s: Session) // return session associated with client close (s: Session) // close session and forget client Note. Client abstracts the implementation details of how the server associates session state with the user’s browser, tab etc. Probably easiest to generate a session id on open and install a cookie containing it.\nA concept that contains all the functionality for remember email addresses and sending emails:\nconcept Email [Principal] purpose support sending progress emails to users principle // if you register a principal with an email // and send an email to that principal // then it will be sent to their address register (p, a); send (p, t) {message {t} sent to p.address} state address: Principal -\u003e one Address actions register (p: Principal, a: Address) forget (p: Principal) send (p: Principal, t: Text) // send a message containing t to p Composing concepts All the concepts are assembled into an app, with one instance of the Buffer and Drill concepts for each session, the Drill concept instantiated so that its tasks are exercises and parts from the Exercise concept, and one instance of the Chatbot concept for each combination of session and task:\napp Tutor includes\tSession Email Exercise Advice [Exercise.Competency] Buffers: Session.Session -\u003e one Buffer Drills: Session.Session -\u003e one Drill[Exercise.Exercise + Exercise.Part] Chatbots: Session.Session -\u003e Drills.Task -\u003e Chatbot Note. There will actually only be one chatbot instance per subtask, even though the declaration suggests one per task.\nWhen a user opens a new session, their email address is registered:\nsync open (c: Client, addr: Email.Address, out s: Session.Session) Session.open (c, s) Email.register (s, addr) When a user selects an exercise, a new task is selected associated with that exercise, and the user’s buffer is cleared:\nsync selectExercise (c: Client, out s: Session, ex: Exercise.Exercise, out exerciseText: Text) Session.getSession (c, s) Exercise.getExercise (ex, exerciseText) Drills[s].selectTask (ex) Buffers[s].open (\"\") The text associated with the exercise (exerciseText) will be displayed to the user.\nWhen a user selects a part of an exercise, a new subtask is selected associated with that exercise, the user’s buffer is reset with the content of the prior solution to that part (or an empty string if none), the advice stored for the competency associated with that part is obtained, and the associated chatbot is prompted with that advice and the textual description of the exercise part:\nsync selectPart (c: Client, out s: Session, ex: Exercise.Exercise, part: Exercise.Part, out comp: Exercise.Competency, out partText: Text, out advice: Text) Session.getSession (c, s) Exercise.getPart (ex, partText, comp, part) Drills[s].selectSubTask (ex, part) Buffers[s].open (emptyIfNone(part.solution)) Advice.getAdvice (comp, advice) Chatbots[s][part].prompt (advice ^ partText) When a user saves the buffer, the content is submitted as a solution (to the current part), that solution is presented as a query to the relevant chatbot, and the solution is also emailed to the user:\nsync submitSolution (c: Client, out s: Session, out solution: Text) Session.getSession (c, s) Drills[s].submit (solution) Buffers[s].save (solution) Chatbots[s][p].ask (solution) Email.send (s, solution) Notes. In this current formulation, the query to the chatbot includes only the solution to the current part of the exercise, but perhaps it should contain the (derived) current version of the entire exercise solution. The chatbot will respond to the query spontaneously; no sync is needed to describe that.\nSummary of Concept Design Ideas Here are some of the principles that guided the conceptual design:\nFactoring. Reasons for factoring out concepts include: standard reusable functionality (Session); separable/optional feature (Email); separable feature with considerable complexity (Buffer, Chatbot); to exploit lifting so that concept need not include indexing (Drill); functionality that is separable and may be subsequently elaborated (Advice). Lifting. Whenever a concept might have included an indexed state component, but the different indexed parts of the state never interact, the concept should instead be lifted. For example, each buffer has its own behavior, and there are no actions across buffers, so rather than having the Buffer concept include an indexed collection of buffers, the concept itself is instantiated, indexed over sessions. Email should probably be lifted too. Abstraction. Details of a concept are excluded if they are not relevant to the essential design questions. For example, Buffer.edit embodies all the complexity of a text editor, but for the purpose of high level design, it’s best just to assume this. Polymorphism. Concepts are made polymorphic when possible. For example, the tasks of the Drill concept and the competencies of Advice can be bound to any types. Concept vs sync design. In some apps, the design of the concepts themselves will be challenging. In this case, the main problem was how they fit together, so laying out the essential actions and figuring out how they would be synced was primary. Open Design Questions The concept design offers only a draft attempt at resolving the tricky questions about how the various parts of the app should interact. Particular decisions embodied in the concept design that should be revisited include:\nAssociating chatbot sessions with parts of exercises. Deriving exercise solutions from part solutions, and not allowing them to be edited explicitly. Conveying solutions to user by emailing submitted solutions to subparts. Clearly, users may prefer an explicit action for sending or saving a solution, which should probably send the entire exercise solution. There should also be a way to send the chatbot transcript. Associating prompts with competencies tied to parts, and not with whole exercises, and feeding the text of the exercise part as part of the prompt. The chatbot instances are associated with parts of exercises, and their sessions persist, so that if you select a part, then select another part and come back to the first, you’ll be in the same session. … ",
  "wordCount" : "2235",
  "inLanguage": "en",
  "datePublished": "2023-05-11T00:00:00Z",
  "dateModified": "2023-05-11T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Daniel Jackson"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://essenceofsoftware.com/drafts/ai-tutor-v2/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "The Essence of Software",
    "logo": {
      "@type": "ImageObject",
      "url": "https://essenceofsoftware.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://essenceofsoftware.com" accesskey="h" title="The Essence of Software (Alt + H)">The Essence of Software</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://essenceofsoftware.com/ask/" title="Q&amp;A">
                    <span>Q&amp;A</span>
                </a>
            </li>
            <li>
                <a href="https://essenceofsoftware.com/buy/" title="Buy">
                    <span>Buy</span>
                </a>
            </li>
            <li>
                <a href="https://essenceofsoftware.com/reviews/" title="Reviews">
                    <span>Reviews</span>
                </a>
            </li>
            <li>
                <a href="https://essenceofsoftware.com/author/" title="Author">
                    <span>Author</span>
                </a>
            </li>
            <li>
                <a href="https://essenceofsoftware.com/posts/" title="Goodies">
                    <span>Goodies</span>
                </a>
            </li>
            <li>
                <a href="https://essenceofsoftware.com/subscribe/" title="Subscribe">
                    <span>Subscribe</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Notes on design of a GPT-powered tutor
    </h1>
    <div class="post-description">
      Notes on design of a GPT-powered tutor
    </div>
    <div class="post-meta"><span title='2023-05-11 00:00:00 +0000 UTC'>May 11, 2023</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Daniel Jackson&nbsp;|&nbsp;<a href="https://forum.softwareconcepts.io" rel="noopener noreferrer" target="_blank">Comments</a>

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul><ul>
                <li>
                    <a href="#goals-and-principles" aria-label="Goals and Principles">Goals and Principles</a></li>
                <li>
                    <a href="#identifying-concepts" aria-label="Identifying concepts">Identifying concepts</a></li>
                <li>
                    <a href="#composing-concepts" aria-label="Composing concepts">Composing concepts</a></li></ul>
                    
                <li>
                    <a href="#summary-of-concept-design-ideas" aria-label="Summary of Concept Design Ideas">Summary of Concept Design Ideas</a></li>
                <li>
                    <a href="#open-design-questions" aria-label="Open Design Questions">Open Design Questions</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="goals-and-principles">Goals and Principles<a hidden class="anchor" aria-hidden="true" href="#goals-and-principles">#</a></h2>
<p>These notes are intended to contribute to the design of a tutor based on GPT that Geoffrey is building for use in Software Studio this fall.</p>
<p>Some of the goals of building and deploying the tutor are:</p>
<ul>
<li>To get some initial experience using GPT-like tools in education;</li>
<li>To help students learn concept design;</li>
<li>To gather data both about students’ learning of concept design and about the performance of the AI tutor;</li>
<li>To refine the pedagogy around concept design.</li>
</ul>
<p>Some design principles of the tutor are:</p>
<ul>
<li>To make the simplest thing that works;</li>
<li>While serving the needs of concept design, to make the tutor as general as possible so that it can be applied in other domains;</li>
<li>To reduce barrier to usage by students;</li>
<li>To make it easy for class staff to change the materials and exercises;</li>
<li>To implement using the class tech stack&ndash;Node/Express, Vue (or React if that’s easier for Geoffrey)&ndash;so the tutor can be used as an exemplar for students and also easily modified by staff;</li>
</ul>
<h2 id="identifying-concepts">Identifying concepts<a hidden class="anchor" aria-hidden="true" href="#identifying-concepts">#</a></h2>
<p>The central concept captures the protocol of interacting with tools like GPT:</p>
<pre><code>concept ChatBot
purpose interact with AI agent
principle
  prompt (t0); ask (t1); respond (t2); ...
state
  prompt: lone Text
  questions, answers: seq Text
actions
  prompt (t: Text)
    // initialize the chatbot with a prompt
  ask (t: Text)
    // user enters text
  respond (t: Text)
    // bot responds
</code></pre>
<p>The prompt will turn out to be a concatenation of distinct components, such as a general tactic for the bot to follow; a pedagogical context for the exercise at hand; and the starting seed for the exercise itself (eg, “ask the user to do X”).</p>
<p>The student will work in a mutable buffer, generating a sequence of immutable texts:</p>
<pre><code>concept Buffer
purpose create immutable text with mutable buffer
principle
  // if you open buffer and edit it,
  // saving produces last content
  open (t); edit (t'); save (ts) {ts = t'}
state
  content: Text
actions
  open (t: Text)
    // reset buffer contents to t
  edit (t: Text)
    // edit buffer content to be t
  save (out t: Text)
    // save contents of buffer
</code></pre>
<p>The <em>save</em> action is intended to be sync’d with another concept; this factors out the means by which the text is saved and where it’s saved to.</p>
<p><strong>Concept design theory aside</strong>. This concept might seem so simple that its functionality should be absorbed into another concept (eg, <em>Drill</em>, below). But this would be a mistake. First, it embodies distinct and complex functionality&ndash;a complete text editor. The <em>edit</em> action represents very abstractly and generally all possible edits. Second, by separating the concept out we’re able to lift it (that is, create an indexed collection of instances without having to pollute any concept with a spurious index type).</p>
<p>The chatbot is fueled by a repository of advice, which I’ll model as a concept that offers advice on various topics:</p>
<pre><code>concept Advice [Topic]
purpose manage repo of advice
principle
  // create topic, add advice, then getting
  // advice will return all advice added to that
  // topic
  newTopic (n, t); addAdvice (t, a1)... addAdvice (t, aN); get (t, a')
    {a' = a1 + ... + aN}
state
  advices: Topic -&gt; set Text
  name: Topic lone -&gt; one Text
actions
  newTopic (name: Text, out t: Topic)
  addAdvice (t: Topic, advice: Text)
  getAdvice (t: Topic, out advices: set Text)
</code></pre>
<p><strong>Concept design theory aside</strong>. Another concept that might seem too simple to represent. In this case, the behavior is indeed very simple, but the concept is factored out because it represents very distinct and domain-dependent functionality, and represents a significant part of the tutor. I’ve included an action <em>getAdvice</em> to help reify the operational principle even though the state is visible and observer actions aren’t generally needed. Could this concept be made more similar to one that already exists, such as a Q&amp;A concept of the sort you might use to model StackOverflow etc? In the AI tutor setting, the advice will be given to the chatbot, not the student, but this should be irrelevant in the design of the concept.</p>
<p>The pedagogical content is organized as a collection of exercises with multiple parts; the parts are associated with competencies (which will be the topics for advice).</p>
<pre><code>concept Exercise
purpose maintain and offer structured exercises
principle
  // admin creates exercise with parts
  // when student selects part, they get 
  // the relevant descriptions
  newExercise(te, e); newPart (e, tp, c, p); getPart (e, p, t', c')
    {t' = te^tp, c' = c}
state
  parts: Exercise one -&gt; set Part
  competency: Part -&gt; one Competency
  description: Exercise + Part -&gt; one Text
actions
  newCompetency (out c: Competency)
  newExercise (t: Text, out e: Exercise)
  newPart (e: Exercise, t: Text, c: Competency, out p: Part)
  getExercise (e: Exercise, out t: Text)
  getPart (e: Exercise, p: Part, out t: Text, out c: Competency)
    // when student selects a part of an exercise,
    // they're given a description that combines
    // the description of the exercise with the 
    // description of the part (and the competency
    // they'll acquire)
</code></pre>
<p><strong>Notes</strong>:</p>
<ul>
<li>Both exercises and their parts have descriptions</li>
<li>Competency associated only with parts and not whole exercises. This will mean we can’t associate advice with exercises as a whole. Perhaps advice common to all parts is just included for those parts?</li>
<li>Parts are not shared between exercises</li>
<li>Considered including student behavior in this concept to make it richer but then decided it was more important to factor it out so that the student behavior concept could be lifted over students (that is, each student behavior being independent)</li>
<li><em>selectexercise</em> was added so that it could be synchronized with the resetting of the buffer as the student begins a new exercise.</li>
<li>Competencies will presumably have textual names, but treating them abstractly in the concept.</li>
</ul>
<p>Concept for student behavior:</p>
<pre><code>concept Drill [Task]
purpose
  store incremental student work on structured task
principle
  // if you select a task and one of its subtasks
  // and then submit a solution, it's recorded
  // appropriately
  selectTask (t); selectSubTask (t, t'); 
  submit (s) {t' in t.subtasks and t.solution = s}
state
  subtasks: Task one -&gt; set Task
  solution: Task -&gt; lone Text
  current: lone Task
actions
  selectTask (t: Task)
    // set current to t
  selectSubTask (super, sub: Task)
    // set current to sub
    // ensure sub a subtask of super
  submit (t: Text)
    // current.solution := t
</code></pre>
<p><strong>Notes</strong>:</p>
<ul>
<li>Decided to make this cursor-based; not sure this is a good idea, but seems useful to have this state somewhere in the app.</li>
<li>OP is not very satisfying but at least suggests how concept is used.</li>
</ul>
<p><strong>An important design issue</strong>. For simplicity, this design assumes that student work is saved only for subtasks (which will correspond to parts of exercises). There is no separate storage of whole exercise solutions. Instead, the text of an exercise solution is derived from the texts of the solutions of the parts. The student may be shown a coherent block of text representing their solution to the whole exercise but will not be able to edit it: only edits to solutions to parts are allowed. The <em>Drill</em> concept maintains the fragmentary solutions; the app can display a solution to an entire exercise by combining state from <em>Exercise</em> and <em>Drill</em>.</p>
<p>A concept is needed to manage student sessions and provide access to students to the work they have done:</p>
<pre><code>concept Session
purpose maintain persistent identities of clients
principle
  // if you open a session on a client and then
  // get the session at the client before closing,
  // you'll get the session that was created on open
  open (c, s); getSession (c, s') {s' = s}
state
  session: Client -&gt; one Session
actions
  open (c: Client, out s: Session)
    // create new session on client
  getSession (c: Client, out s: Session)
    // return session associated with client
  close (s: Session)
    // close session and forget client
</code></pre>
<p><strong>Note</strong>. <em>Client</em> abstracts the implementation details of how the server associates session state with the user’s browser, tab etc. Probably easiest to generate a session id on <em>open</em> and install a cookie containing it.</p>
<p>A concept that contains all the functionality for remember email addresses and sending emails:</p>
<pre><code>concept Email [Principal]
purpose support sending progress emails to users
principle
  // if you register a principal with an email
  // and send an email to that principal
  // then it will be sent to their address
  register (p, a); send (p, t)
    {message {t} sent to p.address}
state
  address: Principal -&gt; one Address
actions
  register (p: Principal, a: Address)
  forget (p: Principal)
  send (p: Principal, t: Text)
    // send a message containing t to p
</code></pre>
<h2 id="composing-concepts">Composing concepts<a hidden class="anchor" aria-hidden="true" href="#composing-concepts">#</a></h2>
<p>All the concepts are assembled into an app, with one instance of the <em>Buffer</em> and <em>Drill</em> concepts for each session, the <em>Drill</em> concept instantiated so that its tasks are exercises and parts from the <em>Exercise</em> concept, and one instance of the <em>Chatbot</em> concept for each combination of session and task:</p>
<pre><code>app Tutor
includes	  
  Session
  Email
  Exercise
  Advice [Exercise.Competency]
  Buffers: Session.Session -&gt; one Buffer
  Drills: Session.Session
    -&gt; one Drill[Exercise.Exercise + Exercise.Part]
  Chatbots: Session.Session -&gt; Drills.Task -&gt; Chatbot
</code></pre>
<p><strong>Note</strong>. There will actually only be one chatbot instance per subtask, even though the declaration suggests one per task.</p>
<p>When a user opens a new session, their email address is registered:</p>
<pre><code>sync open (c: Client, addr: Email.Address, out s: Session.Session)
  Session.open (c, s)
  Email.register (s, addr)
</code></pre>
<p>When a user selects an exercise, a new task is selected associated with that exercise, and the user’s buffer is cleared:</p>
<pre><code>sync selectExercise (c: Client, out s: Session,
     ex: Exercise.Exercise, out exerciseText: Text)
Session.getSession (c, s)
Exercise.getExercise (ex, exerciseText)
Drills[s].selectTask (ex)
Buffers[s].open (&quot;&quot;)
</code></pre>
<p>The text associated with the exercise (<em>exerciseText</em>) will be displayed to the user.</p>
<p>When a user selects a part of an exercise, a new subtask is selected associated with that exercise, the user’s buffer is reset with the content of the prior solution to that part (or an empty string if none), the advice stored for the competency associated with that part is obtained, and the associated chatbot is prompted with that advice and the textual description of the exercise part:</p>
<pre><code>sync selectPart (c: Client, out s: Session,
     ex: Exercise.Exercise, part: Exercise.Part,
     out comp: Exercise.Competency,
     out partText: Text, out advice: Text)
  Session.getSession (c, s)
  Exercise.getPart (ex, partText, comp, part)
  Drills[s].selectSubTask (ex, part)
  Buffers[s].open (emptyIfNone(part.solution))
  Advice.getAdvice (comp, advice)
  Chatbots[s][part].prompt (advice ^ partText)
</code></pre>
<p>When a user saves the buffer, the content is submitted as a solution (to the current part), that solution is presented as a query to the relevant chatbot, and the solution is also emailed to the user:</p>
<pre><code>sync submitSolution (c: Client, out s: Session,
     out solution: Text)
  Session.getSession (c, s)
  Drills[s].submit (solution)
  Buffers[s].save (solution)
  Chatbots[s][p].ask (solution)
  Email.send (s, solution)
</code></pre>
<p><strong>Notes</strong>. In this current formulation, the query to the chatbot includes only the solution to the current part of the exercise, but perhaps it should contain the (derived) current version of the entire exercise solution. The chatbot will respond to the query spontaneously; no sync is needed to describe that.</p>
<h1 id="summary-of-concept-design-ideas">Summary of Concept Design Ideas<a hidden class="anchor" aria-hidden="true" href="#summary-of-concept-design-ideas">#</a></h1>
<p>Here are some of the principles that guided the conceptual design:</p>
<ul>
<li><strong>Factoring</strong>. Reasons for factoring out concepts include: standard reusable functionality (<em>Session</em>); separable/optional feature (<em>Email</em>); separable feature with considerable complexity (<em>Buffer</em>, <em>Chatbot</em>); to exploit lifting so that concept need not include indexing (<em>Drill</em>); functionality that is separable and may be subsequently elaborated (<em>Advice</em>).</li>
<li><strong>Lifting</strong>. Whenever a concept might have included an indexed state component, but the different indexed parts of the state never interact, the concept should instead be lifted. For example, each buffer has its own behavior, and there are no actions across buffers, so rather than having the <em>Buffer</em> concept include an indexed collection of buffers, the concept itself is instantiated, indexed over sessions. <em>Email</em> should probably be lifted too.</li>
<li><strong>Abstraction</strong>. Details of a concept are excluded if they are not relevant to the essential design questions. For example, <em>Buffer.edit</em> embodies all the complexity of a text editor, but for the purpose of high level design, it’s best just to assume this.</li>
<li><strong>Polymorphism</strong>. Concepts are made polymorphic when possible. For example, the tasks of the <em>Drill</em> concept and the competencies of <em>Advice</em> can be bound to any types.</li>
<li><strong>Concept vs sync design</strong>. In some apps, the design of the concepts themselves will be challenging. In this case, the main problem was how they fit together, so laying out the essential actions and figuring out how they would be synced was primary.</li>
</ul>
<h1 id="open-design-questions">Open Design Questions<a hidden class="anchor" aria-hidden="true" href="#open-design-questions">#</a></h1>
<p>The concept design offers only a draft attempt at resolving the tricky questions about how the various parts of the app should interact. Particular decisions embodied in the concept design that should be revisited include:</p>
<ul>
<li>Associating chatbot sessions with parts of exercises.</li>
<li>Deriving exercise solutions from part solutions, and not allowing them to be edited explicitly.</li>
<li>Conveying solutions to user by emailing submitted solutions to subparts. Clearly, users may prefer an explicit action for sending or saving a solution, which should probably send the entire exercise solution. There should also be a way to send the chatbot transcript.</li>
<li>Associating prompts with competencies tied to parts, and not with whole exercises, and feeding the text of the exercise part as part of the prompt.</li>
<li>The chatbot instances are associated with parts of exercises, and their sessions persist, so that if you select a part, then select another part and come back to the first, you’ll be in the same session.</li>
<li>&hellip;</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>

  </footer>
</article>
    </main>
    
<footer class="footer">


    <span>&copy; 2023 <a href="https://essenceofsoftware.com">Daniel Jackson</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
