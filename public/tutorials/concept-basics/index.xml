<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Concept basics on The Essence of Software</title>
    <link>https://essenceofsoftware.com/tutorials/concept-basics/</link>
    <description>Recent content in Concept basics on The Essence of Software</description>
    <image>
      <title>The Essence of Software</title>
      <url>https://essenceofsoftware.com/eos-twitter-card.png</url>
      <link>https://essenceofsoftware.com/eos-twitter-card.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>Daniel Jackson</copyright>
    <lastBuildDate>Mon, 11 Sep 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://essenceofsoftware.com/tutorials/concept-basics/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Concept criteria: what&#39;s a concept?</title>
      <link>https://essenceofsoftware.com/tutorials/concept-basics/criteria/</link>
      <pubDate>Mon, 11 Sep 2023 00:00:00 +0000</pubDate>
      
      <guid>https://essenceofsoftware.com/tutorials/concept-basics/criteria/</guid>
      <description>Two sides of a coin The key to concept design is, perhaps not surprisingly, the idea of concepts. A concept is two things at once. On the one hand, a “concept” means you’d expect it to mean: a mental construct that you need to understand to be able to use an app effectively. So you might that to use Photoshop you need to understand the “concept of a layer”; to use Facebook you need to understand the “concept of friending”; and so on.</description>
    </item>
    
    <item>
      <title>Concept dependencies and subsets</title>
      <link>https://essenceofsoftware.com/tutorials/concept-basics/dependency/</link>
      <pubDate>Mon, 11 Sep 2023 00:00:00 +0000</pubDate>
      
      <guid>https://essenceofsoftware.com/tutorials/concept-basics/dependency/</guid>
      <description>An idea you need to know One of the most important and useful ideas in software also happens to be one of the least well known. It was introduced in a paper that David Parnas wrote in 1979, entitled Designing Software for Ease of Extension and Contraction.
Program families. Following on from an earlier paper that introduced the idea of “program families”&amp;mdash;that when you design software you should realize that you’re designing a whole family of programs, not just one&amp;mdash;this paper addresses the question of how to do this.</description>
    </item>
    
    <item>
      <title>Concept purposes</title>
      <link>https://essenceofsoftware.com/tutorials/concept-basics/purposes/</link>
      <pubDate>Mon, 11 Sep 2023 00:00:00 +0000</pubDate>
      
      <guid>https://essenceofsoftware.com/tutorials/concept-basics/purposes/</guid>
      <description>The role of purposes From what to why. The beginning of wisdom for a designer is to stop asking “what?” and start asking “why?”.
This applies at every level. You can ask “what application shall I design?”. But a better question is “why would I design that?”. And at a finer grain, the question “what features should my app have?” gives way to “why should my app have these particular features?</description>
    </item>
    
    <item>
      <title>Concept state</title>
      <link>https://essenceofsoftware.com/tutorials/concept-basics/state/</link>
      <pubDate>Tue, 23 May 2023 00:00:00 +0000</pubDate>
      
      <guid>https://essenceofsoftware.com/tutorials/concept-basics/state/</guid>
      <description>Motivation: Defining Behavior The operational principle of a concept explains its archetypal behavior: how it’s typically used, and how it fulfills its purpose. But for a concept to be flexible and powerful, it should work in many different scenarios, so we need a way to pin down the behavior in detail.
Using the notion of a state machine, we can define how a concept will behave in every possible situation. Then we can analyze the design to make sure that the behavior is always acceptable.</description>
    </item>
    
    <item>
      <title>Concepts are state machines</title>
      <link>https://essenceofsoftware.com/tutorials/concept-basics/concepts-are-state-machines/</link>
      <pubDate>Wed, 14 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://essenceofsoftware.com/tutorials/concept-basics/concepts-are-state-machines/</guid>
      <description>As I explained in another tutorial, the easiest and most effective way to define the behavior of an app precisely is to model it as a state machine. The app has a set of possible states, and actions that update and query the states. An execution of the app is just a sequence of actions (or more correctly, action instances that include particular action arguments), and the behavior as a whole is the set of all possible executions.</description>
    </item>
    
    <item>
      <title>Software = concepts</title>
      <link>https://essenceofsoftware.com/tutorials/concept-basics/apps-made-of-concepts/</link>
      <pubDate>Tue, 23 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://essenceofsoftware.com/tutorials/concept-basics/apps-made-of-concepts/</guid>
      <description>Any software app, service or system can be viewed as a collection of interacting concepts.
Concepts are the building blocks of software Imagine explaining Twitter to someone who&amp;rsquo;s never used it. You might tell them about the Tweet and Follower concepts, then maybe Hashtag and Like (aka Upvote), and if they&amp;rsquo;re keen to know even more, you could explain VerifiedAccount or Bookmark.
Each concept can be explained with a purpose (what it&amp;rsquo;s for) and an operational principle (how you use it):</description>
    </item>
    
    <item>
      <title>Apps are state machines</title>
      <link>https://essenceofsoftware.com/tutorials/concept-basics/apps-are-state-machines/</link>
      <pubDate>Tue, 02 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://essenceofsoftware.com/tutorials/concept-basics/apps-are-state-machines/</guid>
      <description>If user experience runs deeper than the user interface, we need a way to talk about an app that isn’t just visual, and that captures behavior in a more fundamental way.
Programmers think in terms of complicated things like objects, callbacks, streams, functionals, and so on. They’re essential for structuring code, but for behavior a much simpler model is effective.
State machines That model is the state machine. You’ve probably come across state machines, either in a class about the theory of computation, or seeing diagrams like this:</description>
    </item>
    
    <item>
      <title>Operational Principle</title>
      <link>https://essenceofsoftware.com/tutorials/concept-basics/operational-principle/</link>
      <pubDate>Tue, 02 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://essenceofsoftware.com/tutorials/concept-basics/operational-principle/</guid>
      <description>A compelling way to explain how something works is to tell a story. Not any story, but a kind of defining story that shows, through a typical scenario, why the thing is useful and fulfills its purpose.
The Minuteman Library Network, for example, offers a wonderful service. If I request a book, then when it becomes available at my local library, I get an email notifying me that it’s ready to be picked up.</description>
    </item>
    
  </channel>
</rss>
