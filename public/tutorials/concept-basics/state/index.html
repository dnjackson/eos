<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Concept state | The Essence of Software</title>
<meta name="keywords" content="">
<meta name="description" content="Motivation: Defining Behavior The operational principle of a concept explains its archetypal behavior: how it’s typically used, and how it fulfills its purpose. But for a concept to be flexible and powerful, it should work in many different scenarios, so we need a way to pin down the behavior in detail.
Using the notion of a state machine, we can define how a concept will behave in every possible situation. Then we can analyze the design to make sure that the behavior is always acceptable.">
<meta name="author" content="Daniel Jackson">
<link rel="canonical" href="https://essenceofsoftware.com/tutorials/concept-basics/state/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.2e7233f1eda5b0ed5b65d97b4091e50cb7c049a0f885a948abb89369b8a860cc.css" integrity="sha256-LnIz8e2lsO1bZdl7QJHlDLfASaD4halIq7iTabioYMw=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://essenceofsoftware.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://essenceofsoftware.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://essenceofsoftware.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://essenceofsoftware.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://essenceofsoftware.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-WRQ6HWW3ZW"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-WRQ6HWW3ZW', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="Concept state" />
<meta property="og:description" content="Motivation: Defining Behavior The operational principle of a concept explains its archetypal behavior: how it’s typically used, and how it fulfills its purpose. But for a concept to be flexible and powerful, it should work in many different scenarios, so we need a way to pin down the behavior in detail.
Using the notion of a state machine, we can define how a concept will behave in every possible situation. Then we can analyze the design to make sure that the behavior is always acceptable." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://essenceofsoftware.com/tutorials/concept-basics/state/" /><meta property="og:image" content="https://essenceofsoftware.com/eos-twitter-card.png"/><meta property="article:section" content="tutorials" />
<meta property="article:published_time" content="2023-05-23T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-05-23T00:00:00+00:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://essenceofsoftware.com/eos-twitter-card.png"/>

<meta name="twitter:title" content="Concept state"/>
<meta name="twitter:description" content="Motivation: Defining Behavior The operational principle of a concept explains its archetypal behavior: how it’s typically used, and how it fulfills its purpose. But for a concept to be flexible and powerful, it should work in many different scenarios, so we need a way to pin down the behavior in detail.
Using the notion of a state machine, we can define how a concept will behave in every possible situation. Then we can analyze the design to make sure that the behavior is always acceptable."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Tutorials",
      "item": "https://essenceofsoftware.com/tutorials/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Concept basics",
      "item": "https://essenceofsoftware.com/tutorials/concept-basics/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "Concept state",
      "item": "https://essenceofsoftware.com/tutorials/concept-basics/state/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Concept state",
  "name": "Concept state",
  "description": "Motivation: Defining Behavior The operational principle of a concept explains its archetypal behavior: how it’s typically used, and how it fulfills its purpose. But for a concept to be flexible and powerful, it should work in many different scenarios, so we need a way to pin down the behavior in detail.\nUsing the notion of a state machine, we can define how a concept will behave in every possible situation. Then we can analyze the design to make sure that the behavior is always acceptable.",
  "keywords": [
    
  ],
  "articleBody": "Motivation: Defining Behavior The operational principle of a concept explains its archetypal behavior: how it’s typically used, and how it fulfills its purpose. But for a concept to be flexible and powerful, it should work in many different scenarios, so we need a way to pin down the behavior in detail.\nUsing the notion of a state machine, we can define how a concept will behave in every possible situation. Then we can analyze the design to make sure that the behavior is always acceptable. And as we transition from design to code, the state machine provides an ideal stepping stone. The state of the state machine will become the state of the program and the actions of the state machine will become the functions of its API.\nA relational formulation of state is the best, in my view, because it is abstract enough to avoid making any premature implementation commitments, but at the same time is easily translated into code. For traditional or object-oriented data structures (in languages like JavaScript and Python) or collection databases (like Mongo.db), the translation is usually straightforward; for a relational database (where the state is defined by a schema in SQL) the translation is even easier.\nThe Role of State Novices are sometimes confused about what the actual role of the state of a concept is. Part of the reason for the confusion is that state declarations are very similar to ontologies or knowledge graphs, and this encourages novices to think that the state should somehow embody everything that is known about the relevant objects in the domain and their relationships.\nBut that’s a mistake. The state of a concept plays a very straightforward role, and that’s to determine what the concept remembers at runtime. The state is the concept’s memory. If some piece of information is needed in an action, then it will have to be in the memory; if it will never be needed, it shouldn’t be there, even if it’s interesting.\nFor example, suppose we’re designing a concept called Group for messaging within a group of users. The state will certainly need to include which users belong to which groups, because there will be actions that depend on this (the action post for posting a message will likely check that the user is a member of the group they’re posting in). The state will also need to distinguish regular members of a group from the owner of the group, since some actions (such as approving new members) will only work for owners. Should the state also include the date at which a user joined a group? That would depend on the details of the behavior. If a user who joins a group can only see messages posted after they joined, the date will be necessary, since otherwise this check can’t be performed. But if a user can see all old messages, the date wouldn’t play a useful role, and can be omitted.\nThis criterion of only including in a concept’s state what the concept behavior requires helps divide state up between concepts too. Suppose we’re designing an app for a lending library. We might have a Catalog concept for finding books, and a Hold concept for putting a hold on a book. Since the Hold concept seems to be about books, you might be tempted to include in its state things like the name of a book, or the email address of a user issuing a hold. But this would be a mistake: the Hold concept should support just the actions of creating and tracking holds on books, and for those functions it doesn’t need to know anything about a book except for its identity. The Catalog concept will contain information about a book, including its title. Likewise, the Hold concept will only need to know the identity of a user, and the user’s contact details will be stored in another concept.\nDefining State We’ll define the state of a concept as a series of variable declarations. Each variable will correspond to a set, or to a relation. A relation may map one set to another (in which case it’s called a binary relation), or may associate elements of more than two sets (in which case I call it a multirelation). If you think of a relation as a table, then a binary relation has two columns, and a multirelation has three or more. A set is just a table with one column, so it’s a relation too.\nThis way of thinking about state is taken from the Alloy language, and we’ll use some basic Alloy-like syntax to define the relations.\nFor example, suppose we are designing a concept called Invitation that captures the kind of functionality that appears in many apps in which one user can issue an invitation to another user, to be a friend, to access some files, or whatever. The state of the concept might include\ninvited: User -\u003e User which introduces a relation called invited between users. You can think of a relation like this in several ways: as a mapping from users to users which can be access by a lookup (where u.invited might represent the set of users invited by the user u), as a tuple set or predicate that contains the tuple (u1, u2) when user u1 has invited user u2; or as a table with two columns, with the understanding that the first column represents the inviting user and the second the invited user, and each row represents an invitation. These are all equivalent ways to view a relation.\nIf we want to store the date on which invitation was issued, we could use a three-way relation:\ninvited: User -\u003e User -\u003e one Date where (u1, u2, d) would be included when user u1 invited user u2 on date d. (The multiplicity keyword one says that each pair of users maps to a single date.)\nAnother way to model this would be to introduce a set of invitation objects, and then we can define the date of an invitation and who it’s from and to as additional projections:\nfrom, to: Invitation -\u003e one Person date: Invitation -\u003e one Date As an example of a set declaration, we might have a set of pending invitations that have yet to be accepted:\nPending: set Invitation Novices sometimes wonder why it’s preferable to use a set rather than a mapping to a boolean value. Why not, for example, represent the pending invitations as a relation like this?\nisPending : Invitation -\u003e one Bool The answer is that it’s much easier to write relational expressions about the state using the set rather than the boolean function. For example, the set of users who have issued invitations that are pending can be written as Pending.from; to write this with the boolean function you’d need to construct a set comprehension with a formula.\nAlso, introducing sets lets you include certain invariants in the declaration of the state. For example, suppose the Invitation concept includes a remind action which reminds a user who has received an invitation to accept or reject it, and this action is triggered some fixed time after the invitation is issued. We could represent the time for the reminder like this:\nremindOn: Pending -\u003e one Date which says that each pending invitation has a reminder date. Without the Pending set, we’d need to associate the reminder date with all invitations:\nremindOn: Invitation -\u003e lone Date which says that each invitation is associated with zero or one dates at which the reminder should occur. Because the declaration maps all invitations, not just pending invitations, we have to weaken the multiplicity from one to lone (zero or one), and the invariant that says that every pending invitation has a reminder date is no longer expressed.\nDiagram notation The relation declarations of the state can also be represented in a diagrammatic form. Here, for example, is a diagram for the Invitation concept:\nThis kind of diagram is called an extended entity-relationship diagram. It’s “extended” because it lets you show that one set is a subset of another, in this case that the Pending invitations are a subset of all invitations.\nNote how the diagram expresses the constraint that only pending invitations have reminder dates. This kind of constraint requires subsets and can’t be expressed in standard entity-relationship diagrams.\nPrinciples Here are some principles to help you design the state of a concept:\nSufficiency. The state must be rich enough to support the actions. Put another way, the concept must remember enough about actions in the past to be able to perform actions in the future correctly. Example: an Upvote concept, which tracks how many times users have approved some item, must remember which user issued each upvote in order to prevent double voting, but the date of the upvote would likely not be needed.\nNecessity. Generally, the state should not include components that are not necessary to support the actions. Example: a Reservation concept need not store reservations that have been canceled; a Trash concept need not store the original location of an item if there is no restore action; a Voting concept need not store the time at which a vote occurred, if all votes received before some deadline are treated equally.\nThere is a subtle qualification to this principle. Sometimes it is useful to enrich the state in ways that anticipate future functionality. Example: in a Moderation concept, there might be no actions that require storage of posts that have been rejected by a moderator, but it might be sensible to store them anyway if you anticipate adding, for example, functionality that recommends acceptance or rejection based on treatment of prior posts from the same user.\nRelation direction. The direction in which you declare a relation usually corresponds to the most common direction of lookup. Example: in the Folder concept, the relation between folders and the objects they contain would be declared as\ncontents: Folder lone -\u003e set Object and not\nparent: Object -\u003e lone Folder since you expect to navigate from a folder to its objects, not vice versa. But like tables in a relational database (and unlike mappings in a programming language), the direction of a relation doesn’t fundamentally matter, and you can always do it either way, so you long as you’re consistent in how you refer to it. Example: if an Invitation concept included the relation\ninv: Person -\u003e Person you would have to make sure that you interpreted it consistently, so that p.inv means either the persons invited by p or the persons who have invited p, but not both!\nUnordered relationships. Mathematically, a relation is always directed, and corresponds to a set of ordered pairs or arrows between objects. To represent a symmetric, unordered relationship, you can define a symmetric relation that includes pairs in both directions. Example: the Friend concept may have a relation\nfriends: User -\u003e User that contains both (u1, u2) and (u2, u1) when users u1 and u2 are friends.\nMost abstract structures. The state should not include structural decisions that needlessly complicate the state and limit the freedom of the implementer. In particular, don’t use a sequence (ordering some elements) when a set suffices. Example: you might think that the messages in a Group concept should be stored as a sequence, but since none of the actions involve sequence manipulations, and each message can appear only once, a set of messages is better. If you want the concept to contain enough information for messages to be displayed in order, you can associate a date with each message and assume the mapping of the concept to the user interface sorts messages by date.\nAbstract types. Don’t use a primitive type that has properties that aren’t necessary for the concept behavior. Example: a Ticket concept may generate identifiers for tickets which, in the implementation, will happen to be integers that are generated in order. In the concept design, however, all that matters is that the ticket identifiers are distinct, so you should introduce an abstract type TicketId to represent them rather than using Int.\nRicher abstract types. Another reason to introduce an abstract type is to record in the design that a type will have more properties than a primitive type. Example: rather than representing an email address as String, represent it as an abstract EmailAddress type, to capture the fact that email addresses have a particular form that can be validated.\nPolymorphism. In an app that you’re designing, a concept will often be motivated by a need that is related to a particular kind of object, but the concept itself will not rely on any properties of that object. Example: a Hold concept in a library app that governs how borrowers place holds on books need only associated borrowers with books, and doesn’t need the borrowers or the books to have any particular properties.\nTypes of objects that are not specific to the concept (and are generated by it) should be represented by type parameters, making the concept polymorphic or generic. Example: the Hold concept might be declared as Hold, where User and Item are type variables (that is placeholders for concrete types that will be provided when the concept is used).\nCarrier types. A concept will often introduce a type to represent a set of objects that is central to the concept. In this case, you can overload the name and use it for both the concept and the type, disambiguating them by context. Example: the Group concept has a set of groups of type Group; the Post concept has a set of posts of type Post; the Invitation concept has a set of invitations of type Invitation. When instantiating a polymorphic concept, you can refer to these types in a qualified name. Example: an Upvote concept is defined polymorphically over a generic type of Item (the items that are upvoted). The concept would be declared as Upvote, and can then be instantiated as Upvote to indicate that, in this app, the target items are the posts of the Post concept.\nExample: the Hold from the library app might be instantiated as Hold with a User type from a User concept and a Book type from a LibraryCatalog concept.\nNo external types. Concepts should be fully independent of one another. This is what makes them understandable to users and reusable across applications and even domains. So a concept’s state should never refer to types that are introduced in another concept. Example: an Upvote concept in a social media app should not refer to the type of posts of a Post concept through a state component such as\nconcept Upvote state upvotes: Post -\u003e set Vote Instead, any type whose objects will (at runtime) come from another concept should be declared as a type parameter so that the concept is fully generic (see polymorphism above):\nconcept Upvote state upvotes: Item -\u003e set Vote This principle will actually force you to introduce polymorphism whenever objects are to be shared between concepts, because there’s no other way to say that a type in one concept matches a type in another (except for the primitive types such as String).\nPrimitive types. The standard primitive types are assumed to be defined globally, so a concept can refer to types such as String, Integer, Bool, etc., and use their standard operations (such as concatening strings, adding integers) in defining actions.\nSequences. When an ordered collection of elements is needed, a sequence can be used. Example: in a Chatbot concept, the transcript is a sequence of queries and responses:\nQuery, Response: set Entry transcript: seq (Query + Response) (The plus is a union operator, so Query + Response is the set that includes both queries and responses.)\nConcepts aren’t classes. A common misunderstanding is to think of a concept as a class that has instances, with the concept’s state variables being the instance variables of the class. Example: you might write\nconcept User state friends: set User imagining a collection of user objects each of which points to a set of friends. This is wrong, and assumes a much more complicated set up in which types occurring in state declarations can themselves be concepts. The correct view is that a concept is a state machine whose non-primitive types denote objects only in the sense that they have identity, not in the object-oriented sense of carrying methods and so on. The correct way to write this concept is\nconcept Friend state friends: User -\u003e User which introduces a Friend concept that stores a friend graph.\nBackground Implementation bias. Explain origin in VDM. Response to critique of algebraicists. Example of statistics bag from Carroll Morgan.\n",
  "wordCount" : "2786",
  "inLanguage": "en",
  "datePublished": "2023-05-23T00:00:00Z",
  "dateModified": "2023-05-23T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Daniel Jackson"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://essenceofsoftware.com/tutorials/concept-basics/state/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "The Essence of Software",
    "logo": {
      "@type": "ImageObject",
      "url": "https://essenceofsoftware.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://essenceofsoftware.com" accesskey="h" title="The Essence of Software (Alt + H)">The Essence of Software</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://essenceofsoftware.com/ask/" title="FAQ">
                    <span>FAQ</span>
                </a>
            </li>
            <li>
                <a href="https://essenceofsoftware.com/buy/" title="Buy">
                    <span>Buy</span>
                </a>
            </li>
            <li>
                <a href="https://essenceofsoftware.com/reviews/" title="Reviews">
                    <span>Reviews</span>
                </a>
            </li>
            <li>
                <a href="https://essenceofsoftware.com/author/" title="Author">
                    <span>Author</span>
                </a>
            </li>
            <li>
                <a href="https://essenceofsoftware.com/posts/" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="https://essenceofsoftware.com/tutorials/" title="Tutorials">
                    <span>Tutorials</span>
                </a>
            </li>
            <li>
                <a href="https://essenceofsoftware.com/studies/" title="Case Studies">
                    <span>Case Studies</span>
                </a>
            </li>
            <li>
                <a href="https://essenceofsoftware.com/subscribe/" title="Subscribe">
                    <span>Subscribe</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Concept state
    </h1>
    <div class="post-meta"><span title='2023-05-23 00:00:00 +0000 UTC'>May 23, 2023</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;Daniel Jackson&nbsp;|&nbsp;<a href="https://forum.softwareconcepts.io" rel="noopener noreferrer" target="_blank">Comments</a>

</div>
  </header> 
  <div class="post-content"><h2 id="motivation-defining-behavior">Motivation: Defining Behavior<a hidden class="anchor" aria-hidden="true" href="#motivation-defining-behavior">#</a></h2>
<p>The operational principle of a concept explains its archetypal behavior: how it’s typically used, and how it fulfills its purpose. But for a concept to be flexible and powerful, it should work in many different scenarios, so we need a way to pin down the behavior in detail.</p>
<p>Using the notion of a state machine, we can define how a concept will behave in every possible situation. Then we can analyze the design to make sure that the behavior is always acceptable. And as we transition from design to code, the state machine provides an ideal stepping stone. The state of the state machine will become the state of the program and the actions of the state machine will become the functions of its API.</p>
<p>A relational formulation of state is the best, in my view, because it is abstract enough to avoid making any premature implementation commitments, but at the same time is easily translated into code. For traditional or object-oriented data structures (in languages like JavaScript and Python) or collection databases (like Mongo.db), the translation is usually straightforward; for a relational database (where the state is defined by a schema in SQL) the translation is even easier.</p>
<h2 id="the-role-of-state">The Role of State<a hidden class="anchor" aria-hidden="true" href="#the-role-of-state">#</a></h2>
<p>Novices are sometimes confused about what the actual role of the state of a concept is. Part of the reason for the confusion is that state declarations are very similar to ontologies or knowledge graphs, and this encourages novices to think that the state should somehow embody everything that is known about the relevant objects in the domain and their relationships.</p>
<p>But that’s a mistake. The state of a concept plays a very straightforward role, and that’s to determine what the concept <em>remembers</em> at runtime. The state is the concept’s <em>memory</em>. If some piece of information is needed in an action, then it will have to be in the memory; if it will never be needed, it shouldn’t be there, even if it’s interesting.</p>
<p>For example, suppose we’re designing a concept called <em>Group</em> for messaging within a group of users. The state will certainly need to include which users belong to which groups, because there will be actions that depend on this (the action <em>post</em> for posting a message will likely check that the user is a member of the group they’re posting in). The state will also need to distinguish regular members of a group from the owner of the group, since some actions (such as approving new members) will only work for owners. Should the state also include the date at which a user joined a group? That would depend on the details of the behavior. If a user who joins a group can only see messages posted after they joined, the date will be necessary, since otherwise this check can’t be performed. But if a user can see all old messages, the date wouldn’t play a useful role, and can be omitted.</p>
<p>This criterion of only including in a concept’s state what the concept behavior requires helps divide state up between concepts too. Suppose we’re designing an app for a lending library. We might have a <em>Catalog</em> concept for finding books, and a <em>Hold</em> concept for putting a hold on a book. Since the <em>Hold</em> concept seems to be about books, you might be tempted to include in its state things like the name of a book, or the email address of a user issuing a hold. But this would be a mistake: the <em>Hold</em> concept should support just the actions of creating and tracking holds on books, and for those functions it doesn’t need to know anything about a book except for its identity. The <em>Catalog</em> concept will contain information about a book, including its title. Likewise, the <em>Hold</em> concept will only need to know the identity of a user, and the user’s contact details will be stored in another concept.</p>
<h2 id="defining-state">Defining State<a hidden class="anchor" aria-hidden="true" href="#defining-state">#</a></h2>
<p>We’ll define the state of a concept as a series of variable declarations. Each variable will correspond to a set, or to a relation. A relation may map one set to another (in which case it’s called a <em>binary</em> relation), or may associate elements of more than two sets (in which case I call it a <em>multirelation</em>). If you think of a relation as a table, then a binary relation has two columns, and a multirelation has three or more. A set is just a table with one column, so it’s a relation too.</p>
<p>This way of thinking about state is taken from the Alloy language, and we’ll use some basic Alloy-like syntax to define the relations.</p>
<p>For example, suppose we are designing a concept called <em>Invitation</em> that captures the kind of functionality that appears in many apps in which one user can issue an invitation to another user, to be a friend, to access some files, or whatever. The state of the concept might include</p>
<pre><code>invited: User -&gt; User
</code></pre>
<p>which introduces a relation called <em>invited</em> between users. You can think of a relation like this in several ways: as a <em>mapping</em> from users to users which can be access by a lookup (where <em>u.invited</em> might represent the set of users invited by the user <em>u</em>), as a <em>tuple set</em> or <em>predicate</em> that contains the tuple <em>(u1, u2)</em> when user <em>u1</em> has invited user <em>u2</em>; or as a <em>table</em> with two columns, with the understanding that the first column represents the inviting user and the second the invited user, and each row represents an invitation. These are all equivalent ways to view a relation.</p>
<p>If we want to store the date on which invitation was issued, we could use a three-way relation:</p>
<pre><code>invited: User -&gt; User -&gt; one Date
</code></pre>
<p>where <em>(u1, u2, d)</em> would be included when user <em>u1</em> invited user <em>u2</em> on date <em>d</em>. (The multiplicity keyword <em>one</em> says that each pair of users maps to a single date.)</p>
<p>Another way to model this would be to introduce a set of invitation objects, and then we can define the date of an invitation and who it’s from and to as additional projections:</p>
<pre><code>from, to: Invitation -&gt; one Person
date: Invitation -&gt; one Date
</code></pre>
<p>As an example of a set declaration, we might have a set of pending invitations that have yet to be accepted:</p>
<pre><code>Pending: set Invitation
</code></pre>
<p>Novices sometimes wonder why it’s preferable to use a set rather than a mapping to a boolean value. Why not, for example, represent the pending invitations as a relation like this?</p>
<pre><code>isPending : Invitation -&gt; one Bool
</code></pre>
<p>The answer is that it’s much easier to write relational expressions about the state using the set rather than the boolean function. For example, the set of users who have issued invitations that are pending can be written as <em>Pending.from</em>; to write this with the boolean function you’d need to construct a set comprehension with a formula.</p>
<p>Also, introducing sets lets you include certain invariants in the declaration of the state. For example, suppose the Invitation concept includes a <em>remind</em> action which reminds a user who has received an invitation to accept or reject it, and this action is triggered some fixed time after the invitation is issued. We could represent the time for the reminder like this:</p>
<pre><code>remindOn: Pending -&gt; one Date
</code></pre>
<p>which says that each pending invitation has a reminder date. Without the <em>Pending</em> set, we’d need to associate the reminder date with all invitations:</p>
<pre><code>remindOn: Invitation -&gt; lone Date
</code></pre>
<p>which says that each invitation is associated with zero or one dates at which the reminder should occur. Because the declaration maps all invitations, not just pending invitations, we have to weaken the multiplicity from <em>one</em> to <em>lone</em> (zero or one), and the invariant that says that every pending invitation has a reminder date is no longer expressed.</p>
<h2 id="diagram-notation">Diagram notation<a hidden class="anchor" aria-hidden="true" href="#diagram-notation">#</a></h2>
<p>The relation declarations of the state can also be represented in a diagrammatic form. Here, for example, is a diagram for the <em>Invitation</em> concept:</p>
<p><img loading="lazy" src="invitation-state.jpg" alt=""  />
</p>
<p>This kind of diagram is called an <em>extended entity-relationship</em> diagram. It’s “extended” because it lets you show that one set is a subset of another, in this case that the <em>Pending</em> invitations are a subset of all invitations.</p>
<p>Note how the diagram expresses the constraint that only pending invitations have reminder dates. This kind of constraint requires subsets and can’t be expressed in standard entity-relationship diagrams.</p>
<h2 id="principles">Principles<a hidden class="anchor" aria-hidden="true" href="#principles">#</a></h2>
<p>Here are some principles to help you design the state of a concept:</p>
<p><strong>Sufficiency</strong>. The state must be rich enough to support the actions. Put another way, the concept must remember enough about actions in the past to be able to perform actions in the future correctly. Example: an <em>Upvote</em> concept, which tracks how many times users have approved some item, must remember which user issued each upvote in order to prevent double voting, but the date of the upvote would likely not be needed.</p>
<p><strong>Necessity</strong>. Generally, the state should not include components that are not necessary to support the actions. Example: a <em>Reservation</em> concept need not store reservations that have been canceled; a <em>Trash</em> concept need not store the original location of an item if there is no <em>restore</em> action; a <em>Voting</em> concept need not store the time at which a vote occurred, if all votes received before some deadline are treated equally.</p>
<p>There is a subtle qualification to this principle. Sometimes it is useful to enrich the state in ways that anticipate future functionality. Example: in a <em>Moderation</em> concept, there might be no actions that require storage of posts that have been rejected by a moderator, but it might be sensible to store them anyway if you anticipate adding, for example, functionality that recommends acceptance or rejection based on treatment of prior posts from the same user.</p>
<p><strong>Relation direction</strong>. The direction in which you declare a relation usually corresponds to the most common direction of lookup. Example: in the <em>Folder</em> concept, the relation between folders and the objects they contain would be declared as</p>
<pre><code>contents: Folder lone -&gt; set Object
</code></pre>
<p>and not</p>
<pre><code>parent: Object -&gt; lone Folder
</code></pre>
<p>since you expect to navigate from a folder to its objects, not vice versa. But like tables in a relational database (and unlike mappings in a programming language), the direction of a relation doesn’t fundamentally matter, and you can always do it either way, so you long as you’re consistent in how you refer to it. Example: if an <em>Invitation</em> concept included the relation</p>
<pre><code>inv: Person -&gt; Person
</code></pre>
<p>you would have to make sure that you interpreted it consistently, so that <em>p.inv</em> means either the persons invited by <em>p</em> or the persons who have invited <em>p</em>, but not both!</p>
<p><strong>Unordered relationships</strong>. Mathematically, a relation is always directed, and corresponds to a set of ordered pairs or arrows between objects. To represent a symmetric, unordered relationship, you can define a symmetric relation that includes pairs in both directions. Example: the <em>Friend</em> concept may have a relation</p>
<pre><code>friends: User -&gt; User
</code></pre>
<p>that contains both <em>(u1, u2)</em> and <em>(u2, u1)</em> when users <em>u1</em> and <em>u2</em> are friends.</p>
<p><strong>Most abstract structures</strong>. The state should not include structural decisions that needlessly complicate the state and limit the freedom of the implementer. In particular, don’t use a sequence (ordering some elements) when a set suffices. Example: you might think that the messages in a <em>Group</em> concept should be stored as a sequence, but since none of the actions involve sequence manipulations, and each message can appear only once, a set of messages is better. If you want the concept to contain enough information for messages to be displayed in order, you can associate a date with each message and assume the mapping of the concept to the user interface sorts messages by date.</p>
<p><strong>Abstract types</strong>. Don’t use a primitive type that has properties that aren’t necessary for the concept behavior. Example: a <em>Ticket</em> concept may generate identifiers for tickets which, in the implementation, will happen to be integers that are generated in order. In the concept design, however, all that matters is that the ticket identifiers are distinct, so you should introduce an abstract type <em>TicketId</em> to represent them rather than using <em>Int</em>.</p>
<p><strong>Richer abstract types</strong>. Another reason to introduce an abstract type is to record in the design that a type will have <em>more</em> properties than a primitive type. Example: rather than representing an email address as <em>String</em>, represent it as an abstract <em>EmailAddress</em> type, to capture the fact that email addresses have a particular form that can be validated.</p>
<p><strong>Polymorphism</strong>. In an app that you’re designing, a concept will often be motivated by a need that is related to a particular kind of object, but the concept itself will not rely on any properties of that object. Example: a <em>Hold</em> concept in a library app that governs how borrowers place holds on books need only associated borrowers with books, and doesn’t need the borrowers or the books to have any particular properties.</p>
<p>Types of objects that are not specific to the concept (and are generated by it) should be represented by type parameters, making the concept <em>polymorphic</em> or generic. Example: the <em>Hold</em> concept might be declared as <em>Hold&lt;User, Item&gt;</em>, where <em>User</em> and <em>Item</em> are type variables (that is placeholders for concrete types that will be provided when the concept is used).</p>
<p><strong>Carrier types</strong>. A concept will often introduce a type to represent a set of objects that is central to the concept. In this case, you can overload the name and use it for both the concept and the type, disambiguating them by context. Example: the <em>Group</em> concept has a set of groups of type <em>Group</em>; the <em>Post</em> concept has a set of posts of type <em>Post</em>; the <em>Invitation</em> concept has a set of invitations of type <em>Invitation</em>. When instantiating a polymorphic concept, you can refer to these types in a qualified name. Example: an <em>Upvote</em> concept is defined polymorphically over a generic type of <em>Item</em> (the items that are upvoted). The concept would be declared as <em>Upvote&lt;Item&gt;</em>, and can then be instantiated as <em>Upvote&lt;Post.Post&gt;</em> to indicate that, in this app, the target items are the posts of the <em>Post</em> concept.</p>
<p>Example: the <em>Hold&lt;User, Item&gt;</em> from the library app might be instantiated as <em>Hold&lt;User.User, LibraryCatalog.Book&gt;</em> with a <em>User</em> type from a <em>User</em> concept and a <em>Book</em> type from a <em>LibraryCatalog</em> concept.</p>
<p><strong>No external types</strong>. Concepts should be fully independent of one another. This is what makes them understandable to users and reusable across applications and even domains. So a concept’s state should never refer to types that are introduced in another concept. Example: an <em>Upvote</em> concept in a social media app should not refer to the type of posts of a Post concept through a state component such as</p>
<pre><code>concept Upvote
state
  upvotes: Post -&gt; set Vote
</code></pre>
<p>Instead, any type whose objects will (at runtime) come from another concept should be declared as a type parameter so that the concept is fully generic (see <em>polymorphism</em> above):</p>
<pre><code>concept Upvote &lt;Item&gt;
state
  upvotes: Item -&gt; set Vote
</code></pre>
<p>This principle will actually force you to introduce polymorphism whenever objects are to be shared between concepts, because there’s no other way to say that a type in one concept matches a type in another (except for the primitive types such as <em>String</em>).</p>
<p><strong>Primitive types</strong>. The standard primitive types are assumed to be defined globally, so a concept can refer to types such as <em>String</em>, <em>Integer</em>, <em>Bool</em>, etc., and use their standard operations (such as concatening strings, adding integers) in defining actions.</p>
<p><strong>Sequences</strong>. When an ordered collection of elements is needed, a sequence can be used. Example: in a <em>Chatbot</em> concept, the transcript is a sequence of queries and responses:</p>
<pre><code>Query, Response: set Entry
transcript: seq (Query + Response)
</code></pre>
<p>(The plus is a union operator, so <em>Query + Response</em> is the set that includes both queries and responses.)</p>
<p><strong>Concepts aren’t classes.</strong> A common misunderstanding is to think of a concept as a class that has instances, with the concept’s state variables being the instance variables of the class. Example: you might write</p>
<pre><code>concept User
  state
    friends: set User
</code></pre>
<p>imagining a collection of user objects each of which points to a set of friends. This is wrong, and assumes a much more complicated set up in which types occurring in state declarations can themselves be concepts. The correct view is that a concept is a state machine whose non-primitive types denote objects only in the sense that they have identity, not in the object-oriented sense of carrying methods and so on. The correct way to write this concept is</p>
<pre><code>concept Friend &lt;User&gt;
  state
    friends: User -&gt; User
</code></pre>
<p>which introduces a <em>Friend</em> concept that stores a friend graph.</p>
<h2 id="background">Background<a hidden class="anchor" aria-hidden="true" href="#background">#</a></h2>
<p><strong>Implementation bias.</strong> Explain origin in VDM. Response to critique of algebraicists. Example of statistics bag from Carroll Morgan.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="next" href="https://essenceofsoftware.com/tutorials/concept-basics/apps-made-of-concepts/">
    <span class="title">Next »</span>
    <br>
    <span>Software = concepts</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">


    <span>&copy; 2023 <a href="https://essenceofsoftware.com">Daniel Jackson</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
