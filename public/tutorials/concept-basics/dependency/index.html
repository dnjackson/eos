<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Concept dependencies and subsets | The Essence of Software</title>
<meta name="keywords" content="">
<meta name="description" content="An idea you need to know One of the most important and useful ideas in software also happens to be one of the least well known. It was introduced in a paper that David Parnas wrote in 1979, entitled Designing Software for Ease of Extension and Contraction.
Program families. Following on from an earlier paper that introduced the idea of “program families”&mdash;that when you design software you should realize that you’re designing a whole family of programs, not just one&mdash;this paper addresses the question of how to do this.">
<meta name="author" content="Daniel Jackson">
<link rel="canonical" href="https://essenceofsoftware.com/tutorials/concept-basics/dependency/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.0c5ed6ebd2dfbeba53b78418190f5b01d42289c40be1afa56cc706f62aaa5b23.css" integrity="sha256-DF7W69LfvrpTt4QYGQ9bAdQiicQL4a&#43;lbMcG9iqqWyM=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://essenceofsoftware.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://essenceofsoftware.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://essenceofsoftware.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://essenceofsoftware.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://essenceofsoftware.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-WRQ6HWW3ZW"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-WRQ6HWW3ZW', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="Concept dependencies and subsets" />
<meta property="og:description" content="An idea you need to know One of the most important and useful ideas in software also happens to be one of the least well known. It was introduced in a paper that David Parnas wrote in 1979, entitled Designing Software for Ease of Extension and Contraction.
Program families. Following on from an earlier paper that introduced the idea of “program families”&mdash;that when you design software you should realize that you’re designing a whole family of programs, not just one&mdash;this paper addresses the question of how to do this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://essenceofsoftware.com/tutorials/concept-basics/dependency/" /><meta property="og:image" content="https://essenceofsoftware.com/eos-twitter-card.png"/><meta property="article:section" content="tutorials" />
<meta property="article:published_time" content="2023-09-11T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-09-11T00:00:00+00:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://essenceofsoftware.com/eos-twitter-card.png"/>

<meta name="twitter:title" content="Concept dependencies and subsets"/>
<meta name="twitter:description" content="An idea you need to know One of the most important and useful ideas in software also happens to be one of the least well known. It was introduced in a paper that David Parnas wrote in 1979, entitled Designing Software for Ease of Extension and Contraction.
Program families. Following on from an earlier paper that introduced the idea of “program families”&mdash;that when you design software you should realize that you’re designing a whole family of programs, not just one&mdash;this paper addresses the question of how to do this."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Tutorials",
      "item": "https://essenceofsoftware.com/tutorials/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "On concept design",
      "item": "https://essenceofsoftware.com/tutorials/concept-basics/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "Concept dependencies and subsets",
      "item": "https://essenceofsoftware.com/tutorials/concept-basics/dependency/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Concept dependencies and subsets",
  "name": "Concept dependencies and subsets",
  "description": "An idea you need to know One of the most important and useful ideas in software also happens to be one of the least well known. It was introduced in a paper that David Parnas wrote in 1979, entitled Designing Software for Ease of Extension and Contraction.\nProgram families. Following on from an earlier paper that introduced the idea of “program families”\u0026mdash;that when you design software you should realize that you’re designing a whole family of programs, not just one\u0026mdash;this paper addresses the question of how to do this.",
  "keywords": [
    
  ],
  "articleBody": "An idea you need to know One of the most important and useful ideas in software also happens to be one of the least well known. It was introduced in a paper that David Parnas wrote in 1979, entitled Designing Software for Ease of Extension and Contraction.\nProgram families. Following on from an earlier paper that introduced the idea of “program families”—that when you design software you should realize that you’re designing a whole family of programs, not just one—this paper addresses the question of how to do this. How do you come up with one design that can be easily extended (by adding new functionality) or contracted (by removing functionality)?\nFour flaws. Parnas starts with four flaws that make programs hard to extend or contract. Two are particularly relevant to concept design. One is having a component that serves two different functions. Concept design avoids this by demanding specificity: that each concept has only one purpose. The other is the presence of excessive dependencies. Concept design avoids this by requiring that there are no dependencies between concepts.\nThe uses relation. Parnas then introduces his big idea as a way to address these problems. He calls it the “uses relation.” Today we’d call it a dependency diagram.\nA snarky remark. Even back in 1979, Parnas was aware of the fact that this idea was getting less attention than it deserved. He wrote rather snarkily:\nAfter studying a number of such systems, I have identified some simple concepts that can help programmers to design software so that subsets and extensions are more easily obtained. These concepts are simple if you think about software in the way suggested by this paper. Programmers do not commonly do so.\nIn writing this post, I hope to do my part in putting this right, albeit 40 years later!\nDefining subsets The dependency diagram. Here’s the idea. Suppose our program has components A, B, C, D, etc. We draw a graph with components as nodes and an edge from one component x to another component y if any member of the program family that includes x must also include y.\nFor example, in this diagram the edges from A to B and C mean that any program that includes A also includes B and C; and the edge from B to D means that any program including B includes D.\nThis diagram now implicitly defines a collection of subsets corresponding to each of the programs that might be built. So one subset, for example, is the program that contains only D; another contains B and D. On the other hand, B and C do not form a legitimate program, because any program containing B must also contain D.\nListing all the possible subsets, we get:\n{}, {C}, {D}, {B, D}, {C, D}, {B, C, D}, {A, B, C, D} (I’ve rather pedantically included the empty subset, since it obeys the rules, but admittedly it’s not a very useful program.)\nConcept subsets Let’s apply this idea to concepts. Suppose we have a social media app that has the following concepts:\nPost: share content with others Comment: share reactions to content Friend: limit access to your content User: authenticate a participant Now let’s construct the diagram by taking each of these concepts in turn and asking which other concepts it would require.\nThis question is more subtle than it first appears to be, because it forces you to think about variants of a program that might be unfamiliar.\nSo we start with Post. Now you might assume that a post needs a user to author it. But that’s not true. It would be perfectly possible to have an app in which someone can create a post (and even write in their name as the author) without any kind of user authentication. Admittedly, this might not work too well for a large-scale social media app, but it might be just fine for a noticeboard inside an organization. (A puzzle for curious readers: what would the consequences be of not having a User concept if the Post concept included an edit action?)\nThe Comment concept is simpler. It clearly requires the Post concept, because if there are no posts, there’s nothing to comment on!\nHow about Friend? You might imagine that Friend could be present without Post, in an app that lets you navigate a graph of friendships independently of any content. And indeed, that’s how friending worked in the earliest social media apps (notably Friendster).\nBut the Friend concept that we’re familiar with (from Facebook) is a very different beast. Its purpose is to not support navigation through the graph of connections but to control access to content (and also to filter what content you see, although that’s arguably a different purpose that should be separated out). Moreover, if the Friend concept were to play the role it played in apps like Friendster, we’d need an additional concept to hold information about a user (such as Profile or HomePage), but no such concept is present in our design.\nConsequently, Friend must require Post, because without content there can be no access to control. Friend also requires User, because it can’t work without authors of posts being authenticated.\nFinally, User itself requires Friend, because without Friend there is no reason to include User.\nThe resulting diagram looks like this:\nUsing the dependency diagram So now you have a dependency diagram, what can you do with it?\nClarifying the role of concepts. First, let’s recognize that the construction of the diagram alone forced us to think hard about the role the concepts play in our design. If we’d just thrown the concepts together and not considered their dependencies, we would surely have realized that Comment builds on Post, but we might not have understood how Friend and Post are related.\nSubsets: a family of programs. One dependence diagram defines a collection of possible subsets. For our social media app, we have the following subsets\n1. {Post} 2. {Comment, Post} 3. {User, Friend, Post} 4. {User, Friend, Post, Comment} each corresponding to a different app: (1) a noticeboard app in which people can post anonymous or unauthenticated messages; (2) the same app with comments; (3) a rudimentary social media app with user authentication and a friend network; (4) the same app with comments.\nExplanation order. An advantage of using familiar concepts is that they don’t need to be explained to most users. But there will always be a need for training material that explains how to use an app, especially when the app is complex or contains novel concepts. Because concepts are freestanding and can be understood independently of one another, they can be presented separately.\nBut if you’re explaining concepts in some order, or encouraging users to learn them in some order, the diagram can suggest orders that make the most sense. The rule is that if concept A requires concept B, you want to explain B before A. So that means that an order such as\nis good, but\nis less good, because the Friend concept isn’t motivated until you see Post (when you can explain that the idea is to share posts with your friends), and likewise Comment doesn’t make sense until you’ve seen Post.\nNote, by the way, that the mutual relationship between Friend and User means that there’s no order of one concept at a time that satisfies the rule: those two have to be explained together.\nIntrinsic dependencies Concrete descriptions. Let’s move to thinking of software components not in terms of abstract functionality but in terms of their description, whether some text describing a component at the design level, or some code that implements a component.\nIntrinsic dependencies. Now the possibility arises that a component contains an explicit reference to another component. At the abstract level, its design mentions the other component; or at the code level, it makes a call to it (for example). I call such a dependency an “intrinsic dependency” because it’s part of the component itself rather than a property of the overall design. When is such a dependency legitimate?\nParnas’s rule. In his paper, Parnas gives the following rule: if a component A has an intrinsic dependency on a component B, then there should be no plausible subset that contains A but not B.\nThat sounds complicated, but it’s really very simple. Putting it more simply:\nIf you can’t use A without B, you should never want to use A without B. The uses relation. True confessions: Parnas doesn’t start with the interpretation of the diagram that I started with. In fact, he follows exactly the reverse path. He suggests that you construct a “uses relation” with an edge from A to B whenever A uses B (that is, has an intrinsic dependency on it). The diagram you obtain from this then defines the subsets that are actually possible; you then check it to see if they are desirable (or more accurately that some important subsets are not possible).\nExample of bad code. For example, suppose we were building our social media app in an object-oriented style, and we defined two classes Post and Comment that implemented those concepts. Now suppose that each post contained a list of the associated comments:\nclass Post { List comments; ... } This is, in fact, the way many inexperienced programmers might write this code. Notice that this introduces an intrinsic dependency of Post on Comment. According to Parnas’s rule, that means there should be no variant of the app in which there are posts but no comments.\nClearly that’s absurd! The intrinsic dependency is exactly the wrong way round. If there were to be a dependency, it should be of Comment on Post, and not Post on Comment.\nUnfortunately, achieving that is not so easy in OOP. The problem is that dependencies tend to follow the direction of data navigation, and since the programmer will likely want to go from a post to its associated comments (so they can displayed along with the post), the dependency goes in that direction too.\nThere are various ways around this in OOP, but that’s another subject. So I’ll just point out here that the problem doesn’t arise in a relational setting, in which the Post and Comment concepts are implemented as modules each with their own database tables. The Comment concept can then hold a table mapping posts to comments, and navigating from a post to its comments just involves performing a relational join.\nApplying this to concepts. Back to concepts. Unlike many other kinds of software modules, concepts are always independent, so there are no intrinsic dependencies. That’s why I started with subset interpretation of the dependency diagram: it’s the only one that matters.\nIndependent? What?. Aren’t I contradicting myself? I’ve just said that concepts are always mutually independent, but doesn’t the dependency diagram show dependencies? The resolution of this apparent contradiction is that we’re talking about two different kinds of dependencies. Concepts have no intrinsic dependencies, but they have dependencies in the context of the application design.\nSo the Comment concept has no intrinsic dependence on the Post. To understand comments, you don’t need to know about posts. This is achieved by describing the Comment concept generically in terms of some arbitrary targets that comments can point to; they could be posts, but they could also be newspaper columns or answers in a Q\u0026A forum. In computer science lingo, Comment is polymorphic.\nBut in the context of our social media app, including the Comment concept makes no sense without the Post concept, because there aren’t any other suitable targets for the comments. So there is an extrinsic dependency of Comment on Post, but not an intrinsic one.\nA parting thought. Lest you imagine that intrinsic dependencies are simple, let me make your life a bit harder. When you try to pin down exactly what it means for one component to “use” another, most simple attempts fail. You might start by saying that A uses B if A makes a call to B. But then a round-robin scheduler that calls each of its tasks in turn “uses” those tasks (even though it’s actually the tasks that depend on the scheduler). In a paper I wrote with Jimmy Koppel, we present a collection of such puzzles, and suggest some ideas for a more robust notion of intrinsic dependency.\n",
  "wordCount" : "2067",
  "inLanguage": "en",
  "datePublished": "2023-09-11T00:00:00Z",
  "dateModified": "2023-09-11T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Daniel Jackson"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://essenceofsoftware.com/tutorials/concept-basics/dependency/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "The Essence of Software",
    "logo": {
      "@type": "ImageObject",
      "url": "https://essenceofsoftware.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://essenceofsoftware.com" accesskey="h" title="The Essence of Software (Alt + H)">The Essence of Software</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://essenceofsoftware.com/ask/" title="FAQ">
                    <span>FAQ</span>
                </a>
            </li>
            <li>
                <a href="https://essenceofsoftware.com/buy/" title="Buy">
                    <span>Buy</span>
                </a>
            </li>
            <li>
                <a href="https://essenceofsoftware.com/reviews/" title="Reviews">
                    <span>Reviews</span>
                </a>
            </li>
            <li>
                <a href="https://essenceofsoftware.com/author/" title="Author">
                    <span>Author</span>
                </a>
            </li>
            <li>
                <a href="https://essenceofsoftware.com/posts/" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="https://essenceofsoftware.com/tutorials/" title="Tutorials">
                    <span>Tutorials</span>
                </a>
            </li>
            <li>
                <a href="https://essenceofsoftware.com/studies/" title="Case Studies">
                    <span>Case Studies</span>
                </a>
            </li>
            <li>
                <a href="https://essenceofsoftware.com/subscribe/" title="Subscribe">
                    <span>Subscribe</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Concept dependencies and subsets
    </h1>
    <div class="post-meta"><span title='2023-09-11 00:00:00 +0000 UTC'>September 11, 2023</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Daniel Jackson&nbsp;|&nbsp;<a href="https://forum.essenceofsoftware.com" rel="noopener noreferrer" target="_blank">Comments</a>

</div>
  </header> 
  <div class="post-content"><h2 id="an-idea-you-need-to-know">An idea you need to know<a hidden class="anchor" aria-hidden="true" href="#an-idea-you-need-to-know">#</a></h2>
<p>One of the most important and useful ideas in software also happens to be one of the least well known. It was introduced in a <a href="https://ieeexplore.ieee.org/document/1702607">paper</a> that <a href="https://en.wikipedia.org/wiki/David_Parnas">David Parnas</a> wrote in 1979, entitled <em>Designing Software for Ease of Extension and Contraction</em>.</p>
<p><strong>Program families</strong>. Following on from an earlier paper that introduced the idea of “program families”&mdash;that when you design software you should realize that you’re designing a whole family of programs, not just one&mdash;this paper addresses the question of how to do this. How do you come up with one design that can be easily extended (by adding new functionality) or contracted (by removing functionality)?</p>
<p><strong>Four flaws</strong>. Parnas starts with four flaws that make programs hard to extend or contract. Two are particularly relevant to concept design. One is having a component that serves two different functions. Concept design avoids this by demanding <em>specificity</em>: that each concept has only one purpose. The other is the presence of excessive dependencies. Concept design avoids this by requiring that there are <em>no</em> dependencies between concepts.</p>
<p><strong>The uses relation</strong>. Parnas then introduces his big idea as a way to address these problems. He calls it the “uses relation.” Today we’d call it a <em>dependency diagram</em>.</p>
<p><strong>A snarky remark</strong>. Even back in 1979, Parnas was aware of the fact that this idea was getting less attention than it deserved. He wrote rather snarkily:</p>
<blockquote>
<p>After studying a number of such systems, I have identified some simple concepts that can help programmers to design software so that subsets and extensions are more easily obtained. These concepts are simple if you think about software in the way suggested by this paper. Programmers do not commonly do so.</p>
</blockquote>
<p>In writing this post, I hope to do my part in putting this right, albeit 40 years later!</p>
<h2 id="defining-subsets">Defining subsets<a hidden class="anchor" aria-hidden="true" href="#defining-subsets">#</a></h2>
<p><strong>The dependency diagram</strong>. Here’s the idea. Suppose our program has components A, B, C, D, etc. We draw a graph with components as nodes and an edge from one component <em>x</em> to another component <em>y</em> if any member of the program family that includes <em>x</em> must also include <em>y</em>.</p>
<p>For example, in this diagram the edges from A to B and C mean that any program that includes A also includes B and C; and the edge from B to D means that any program including B includes D.</p>
<p><img loading="lazy" src="abcd.png" alt=""  />
</p>
<p>This diagram now implicitly defines a collection of subsets corresponding to each of the programs that might be built. So one subset, for example, is the program that contains only D; another contains B and D. On the other hand, B and C do not form a legitimate program, because any program containing B must also contain D.</p>
<p>Listing all the possible subsets, we get:</p>
<pre><code>{}, {C}, {D}, {B, D}, {C, D}, {B, C, D}, {A, B, C, D}
</code></pre>
<p>(I’ve rather pedantically included the empty subset, since it obeys the rules, but admittedly it’s not a very useful program.)</p>
<h2 id="concept-subsets">Concept subsets<a hidden class="anchor" aria-hidden="true" href="#concept-subsets">#</a></h2>
<p>Let’s apply this idea to concepts. Suppose we have a social media app that has the following concepts:</p>
<pre><code>Post: share content with others
Comment: share reactions to content
Friend: limit access to your content
User: authenticate a participant
</code></pre>
<p>Now let’s construct the diagram by taking each of these concepts in turn and asking which other concepts it would require.</p>
<p>This question is more subtle than it first appears to be, because it forces you to think about variants of a program that might be unfamiliar.</p>
<p>So we start with <em>Post</em>. Now you might assume that a post needs a user to author it. But that’s not true. It would be perfectly possible to have an app in which someone can create a post (and even write in their name as the author) without any kind of user authentication. Admittedly, this might not work too well for a large-scale social media app, but it might be just fine for a noticeboard inside an organization. (A puzzle for curious readers: what would the consequences be of not having a <em>User</em> concept if the <em>Post</em> concept included an <em>edit</em> action?)</p>
<p>The <em>Comment</em> concept is simpler. It clearly requires the <em>Post</em> concept, because if there are no posts, there’s nothing to comment on!</p>
<p>How about <em>Friend</em>? You might imagine that <em>Friend</em> could be present without <em>Post</em>, in an app that lets you navigate a graph of friendships independently of any content. And indeed, that’s how friending worked in the earliest social media apps (notably <a href="https://en.wikipedia.org/wiki/Friendster">Friendster</a>).</p>
<p>But the <em>Friend</em> concept that we’re familiar with (from Facebook) is a very different beast. Its purpose is to not support navigation through the graph of connections but to control access to content (and also to filter what content you see, although that’s arguably a different purpose that should be separated out). Moreover, if the <em>Friend</em> concept were to play the role it played in apps like Friendster, we’d need an additional concept to hold information about a user (such as <em>Profile</em> or <em>HomePage</em>), but no such concept is present in our design.</p>
<p>Consequently, <em>Friend</em> must require <em>Post</em>, because without content there can be no access to control. <em>Friend</em> also requires <em>User</em>, because it can’t work without authors of posts being authenticated.</p>
<p>Finally, <em>User</em> itself requires <em>Friend</em>, because without <em>Friend</em> there is no reason to include <em>User</em>.</p>
<p>The resulting diagram looks like this:</p>
<p><img loading="lazy" src="social.png" alt=""  />
</p>
<h2 id="using-the-dependency-diagram">Using the dependency diagram<a hidden class="anchor" aria-hidden="true" href="#using-the-dependency-diagram">#</a></h2>
<p>So now you have a dependency diagram, what can you do with it?</p>
<p><strong>Clarifying the role of concepts</strong>. First, let’s recognize that the construction of the diagram alone forced us to think hard about the role the concepts play in our design. If we’d just thrown the concepts together and not considered their dependencies, we would surely have realized that <em>Comment</em> builds on <em>Post</em>, but we might not have understood how <em>Friend</em> and <em>Post</em> are related.</p>
<p><strong>Subsets: a family of programs</strong>. One dependence diagram defines a collection of possible subsets. For our social media app, we have the following subsets</p>
<pre><code>1. {Post}
2. {Comment, Post}
3. {User, Friend, Post}
4. {User, Friend, Post, Comment}
</code></pre>
<p>each corresponding to a different app:  (1) a noticeboard app in which people can post anonymous or unauthenticated messages; (2) the same app with comments; (3) a rudimentary social media app with user authentication and a friend network; (4) the same app with comments.</p>
<p><strong>Explanation order</strong>. An advantage of using familiar concepts is that they don’t need to be explained to most users. But there will always be a need for training material that explains how to use an app, especially when the app is complex or contains novel concepts. Because concepts are freestanding and can be understood independently of one another, they can be presented separately.</p>
<p>But if you’re explaining concepts in some order, or encouraging users to learn them in some order, the diagram can suggest orders that make the most sense. The rule is that if concept A requires concept B, you want to explain B before A. So that means that an order such as</p>
<pre><code>&lt;Post, Comment, Friend&gt;
</code></pre>
<p>is good, but</p>
<pre><code>&lt;Friend, Comment, Post&gt;
</code></pre>
<p>is less good, because the <em>Friend</em> concept isn’t motivated until you see <em>Post</em> (when you can explain that the idea is to share posts with your friends), and likewise <em>Comment</em> doesn’t make sense until you’ve seen <em>Post</em>.</p>
<p>Note, by the way, that the mutual relationship between <em>Friend</em> and <em>User</em> means that there’s no order of one concept at a time that satisfies the rule: those two have to be explained together.</p>
<h2 id="intrinsic-dependencies">Intrinsic dependencies<a hidden class="anchor" aria-hidden="true" href="#intrinsic-dependencies">#</a></h2>
<p><strong>Concrete descriptions</strong>. Let’s move to thinking of software components not in terms of abstract functionality but in terms of their description, whether some text describing a component at the design level, or some code that implements a component.</p>
<p><strong>Intrinsic dependencies</strong>. Now the possibility arises that a component contains an explicit reference to another component. At the abstract level, its design mentions the other component; or at the code level, it makes a call to it (for example). I call such a dependency an “intrinsic dependency” because it’s part of the component itself rather than a property of the overall design. When is such a dependency legitimate?</p>
<p><strong>Parnas’s rule</strong>. In his paper, Parnas gives the following rule: if a component A has an intrinsic dependency on a component B, then there should be no plausible subset that contains A but not B.</p>
<p>That sounds complicated, but it’s really very simple. Putting it more simply:</p>
<pre><code>If you can’t use A without B, you should never want to use A without B.
</code></pre>
<p><strong>The uses relation</strong>. True confessions: Parnas doesn’t start with the interpretation of the diagram that I started with. In fact, he follows exactly the reverse path. He suggests that you construct a “uses relation” with an edge from A to B whenever A <em>uses</em> B (that is, has an intrinsic dependency on it). The diagram you obtain from this then defines the subsets that are actually <em>possible</em>; you then check it to see if they are <em>desirable</em> (or more accurately that some important subsets are <em>not possible</em>).</p>
<p><strong>Example of bad code</strong>. For example, suppose we were building our social media app in an object-oriented style, and we defined two classes <em>Post</em> and <em>Comment</em> that implemented those concepts. Now suppose that each post contained a list of the associated comments:</p>
<pre><code>class Post {
  List&lt;Comment&gt; comments;
  ...
  }
</code></pre>
<p>This is, in fact, the way many inexperienced programmers might write this code. Notice that this introduces an intrinsic dependency of <em>Post</em> on <em>Comment</em>. According to Parnas’s rule, that means there should be no variant of the app in which there are posts but no comments.</p>
<p>Clearly that’s absurd! The intrinsic dependency is exactly the wrong way round. If there were to be a dependency, it should be of <em>Comment</em> on <em>Post</em>, and not <em>Post</em> on <em>Comment</em>.</p>
<p>Unfortunately, achieving that is not so easy in OOP. The problem is that dependencies tend to follow the direction of data navigation, and since the programmer will likely want to go from a post to its associated comments (so they can displayed along with the post), the dependency goes in that direction too.</p>
<p>There are various ways around this in OOP, but that’s another subject. So I’ll just point out here that the problem doesn’t arise in a relational setting, in which the <em>Post</em> and <em>Comment</em> concepts are implemented as modules each with their own database tables. The <em>Comment</em> concept can then hold a table mapping posts to comments, and navigating from a post to its comments just involves performing a relational join.</p>
<p><strong>Applying this to concepts</strong>. Back to concepts. Unlike many other kinds of software modules, concepts are always <a href="https://essenceofsoftware.com/tutorials/concept-basics/criteria/">independent</a>, so there are no intrinsic dependencies. That’s why I started with subset interpretation of the dependency diagram: it’s the only one that matters.</p>
<p><strong>Independent? What?</strong>. Aren’t I contradicting myself? I’ve just said that concepts are always mutually independent, but doesn’t the dependency diagram show dependencies? The resolution of this apparent contradiction is that we’re talking about two different kinds of dependencies. Concepts have no <em>intrinsic</em> dependencies, but they have dependencies in the <em>context</em> of the application design.</p>
<p>So the <em>Comment</em> concept has no intrinsic dependence on the <em>Post</em>. To understand comments, you don’t need to know about posts. This is achieved by describing the <em>Comment</em> concept generically in terms of some arbitrary targets that comments can point to; they could be posts, but they could also be newspaper columns or answers in a Q&amp;A forum. In computer science lingo, <em>Comment</em> is <em>polymorphic</em>.</p>
<p>But in the context of our social media app, including the <em>Comment</em> concept makes no sense without the <em>Post</em> concept, because there aren’t any other suitable targets for the comments. So there is an <em>extrinsic</em> dependency of <em>Comment</em> on <em>Post</em>, but not an intrinsic one.</p>
<p><strong>A parting thought</strong>. Lest you imagine that intrinsic dependencies are simple, let me make your life a bit harder. When you try to pin down exactly what it means for one component to “use” another, most simple attempts fail. You might start by saying that A uses B if A makes a call to B. But then a round-robin scheduler that calls each of its tasks in turn “uses” those tasks (even though it’s actually the tasks that depend on the scheduler). In a <a href="https://groups.csail.mit.edu/sdg/pubs/2020/demystifying_dependence_published.pdf">paper</a> I wrote with <a href="https://www.jameskoppel.com">Jimmy Koppel</a>, we present a collection of such puzzles, and suggest some ideas for a more robust notion of intrinsic dependency.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://essenceofsoftware.com/tutorials/concept-basics/sync/">
    <span class="title">« Prev</span>
    <br>
    <span>Concept composition and sync</span>
  </a>
  <a class="next" href="https://essenceofsoftware.com/tutorials/design-general/divergent-tactics/">
    <span class="title">Next »</span>
    <br>
    <span>Tactics for divergent design</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">


    <span>&copy; 2024 <a href="https://essenceofsoftware.com">Daniel Jackson</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
