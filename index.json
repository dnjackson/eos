[{"content":"The secret of great design Watch great designers at work, or study their designs, and you may wonder: what\u0026rsquo;s their secret? Are they preternaturally inventive? Do they have better taste and judgment than the rest of us? Perhaps, but I don\u0026rsquo;t believe that this can account for the best designs. Based on my own experience studying design and designers (mostly but not exclusively for software), I\u0026rsquo;d attribute the success of great designers to two factors.\nFirst, they\u0026rsquo;ve done it before. Contrary to the picture of design implicit in the design thinking movement—in which extraordinary ideas emerge out of the blue, and each design problem is considered afresh—most designs are adaptations, extensions and compositions of design ideas that came before. A great designer is able to see the essence of a problem, find analogies to problems previously encountered, and rework old solutions.\nSecond, they refine their work. Nobody can solve a challenging problem in one step. What distinguishes great designers from mediocre ones isn\u0026rsquo;t that their first attempts are so much better, but that they critique their work ruthlessly, and keep polishing it until no more improvement seems possible. This observation is not unique to design; George Saunders says it\u0026rsquo;s the secret of great writing too (and perhaps it\u0026rsquo;s a general life strategy).\nImplications for software design Each of these has its implications. The first suggests we might codify a collection of reusable design ideas—both patterns (reusable solutions) and design moves (reusable tactics)—for software. Patterns have been very influential in software engineering (that is, in shaping implementation structures), and concept design is an attempt to find patterns in software design (that is, in shaping behavioral structures). Design moves have been discussed less but are no less important.\nThe second suggests that we need language, structures and design criteria for expressing and evaluating software designs, and that we need to engage in intensive critique of our designs. User testing is valuable, because you usually learn surprising things from people who approach your designs without your preconceptions. But like any form of testing, it doesn\u0026rsquo;t directly help you make a better product. Think about testing code: it can expose bugs (although rarely the subtle ones), but if you just fix each bug as you find it, you\u0026rsquo;re not going to end up with reliable and robust code. Whereas testing encourages you to focus on local details, and to fix problems with patches that can even reduce clarity and uniformity, critique focuses your attention on the essential and more structural aspects of a design and tends to lead to adjustments that produce better overall alignment and consistency.\nAlthough design thinking has done good things, raising awareness of design and encouraging people in all walks of life to see new opportunities for design, it has also tended—perhaps because of its emphasis on democratization of design—to undermine expertise and the value of critique. Natasha Jen, a Pentagram designer, pokes fun at design thinking for these flaws.\nConcept design moves Thinking about design moves, I came to realize that many of the case studies that I analyze in EOS involve one or more simple tactics. I\u0026rsquo;ve classified them into 3 pairs of design moves, each pair comprising a move and its dual. A design move isn\u0026rsquo;t a panacea; it trades off one quality of the design for another. If applied skillfully though, a single move can transform a design from good to great.\nI outline the design moves and give examples of their application in a paper that I\u0026rsquo;ll be presenting in a keynote at the NASA Formal Methods conference in May. (Also see slides on this topic from my recent talk at the Boston ACM/IEEE chapter.) Here, I\u0026rsquo;ll just give a taste of the moves.\nSplit/merge. Split breaks a concept into multiple smaller concepts; merge forms a composite concept from distinct ones. The tradeoff here is between simplicity and power: with more than one concept, the user has more control but things are also more complicated.\nUnify/specialize. Unify takes a collection of concepts that are variants on a theme and unifies them in a single concept specialize breaks a single concept into more specialized variants. The tradeoff here is between generality and problem fit; when you unify, you end up with fewer and more general concepts, but they don\u0026rsquo;t fit the specific applications quite so well.\nTighten/loosen. Tighten increases the synchronization between concepts; loosen weakens it. The tradeoff here is between automation and flexibility. With tight synchronization, the user does less but also has fewer options.\nA language of design: an example Design moves—and concepts—don\u0026rsquo;t guarantee that your designs will be good. But they give you a language for thinking about design, and a way to turn what might otherwise be an intimidating pile of seemingly arbitrary design options into a structured design space that can be navigated more systematically.\nRather than repeating examples from the paper, I\u0026rsquo;ll illustrate this idea with a design move that has yet to be applied. In EOS, I briefly discussed the problem of raised hands in Zoom. People in a meeting raise their (virtual) hands to request to talk, and when their turn comes, they unmute themselves but often forget to lower their hands again. The host, on later spotting the hand still raised, has to ask: is that from before, or a new request to speak?\nWhen I think about this problem, two design moves come to mind. One is the tighten move: we could synchronize the RaisedHand and Mute concepts so that (for example) when you unmute yourself your hand is automatically lowered. This would allow the two concepts to continue to be used mostly independently, but it would have the annoying consequence of lowering your hand (and losing your place in the queue) if you momentarily (and unintentionally) unmute yourself.\nAnother option is to apply the merge move to combine the RaisedHand and Mute concepts into a single concept, Moderation say, for moderated discussions. When the host switches to moderation mode, all non-hosts are muted by default and have to raise a hand to speak. The moderator chooses each speaker in turn, and their hand is lowered and they are simultaneously unmuted. This is arguably a simpler solution, but it eliminates the ability to use muting in a more ad hoc way.\nThis second approach suggests to me that the Mute concept might be serving two distinct purposes: that is, in concept lingo, it\u0026rsquo;s overloaded. One purpose is to let participants in a meeting turn off their microphone for privacy, and the other is to control who is allowed to speak. This suggests applying a split move in which Mute is split into Privacy, a concept that lets users control what other users can see and hear of them, and Permission, which grants users the right to be seen and heard. Our merge move may then be applied to Permission and RaisedHand, leaving Privacy as a distinct concept, which might support some needs more directly. For example, Privacy might provide a toggling action for \u0026ldquo;going private\u0026rdquo; when you want to take a brief break.\nAs always, the challenge will be to balance richness of functionality and automation on the one hand with maintaining simplicity and not overwhelming the user with controls on the other.\nLet\u0026rsquo;s help Zoom! Here\u0026rsquo;s an experiment in community design. Let\u0026rsquo;s together develop a design to address the Zoom raised-hands problem in the concept forum. I\u0026rsquo;ll post these initial ideas to get the topic going.\nFrom my newsletter: archives and signup here.\n","permalink":"https://essenceofsoftware.com/posts/design-moves/","summary":"Or how to become a great software designer.","title":"Design Moves for Software"},{"content":"Dark patterns are no longer just yucky strategies that companies get away with, tempting you to buy insurance you don\u0026rsquo;t need or sign up for a free-for-a-while trial that can only be canceled by calling a phone number that is always busy. Soon they might be illegal. Regulators are taking a closer look, and lawyers in the US and the UK are starting to warn about the liabilities they bring.\nBut what exactly makes a pattern dark? Where is the line between an aggressive but legitimate sales tactic and an immoral or illegal scheme?\nA new project In a research project funded by a new NSF program about designing accountable software systems, I\u0026rsquo;m working with my students Geoffrey Litt and Josh Pollock (and my co-PIs Danny Weitzner and Joan Feigenbaum and their students) on answering this question.\nOur initial take involves—surprise!—software concepts. To date, dark patterns work has focused on user interface tricks: getting you to click the big green button, for example, when it\u0026rsquo;s really that small text field that doesn\u0026rsquo;t even look like a button that you want to click instead. But the more serious dark patterns run deeper, and are conceptual in nature.\nAs bad as it gets For example, in one of the most egregious scams I\u0026rsquo;ve ever seen (thanks so Eunsuk Kang for telling me about this), Intuit advertises a version of the Turbotax tax filing app as \u0026ldquo;guaranteed free.\u0026rdquo; In fact, however, as Propublica has documented, the app is far from free, and if you fail to fall within a narrow range of cases, you will be required to pay (after, of course, you\u0026rsquo;ve taken all the trouble to enter your private and personal tax data). Intuit and other tax software companies had lobbied to prevent the IRS from offering its own free solution (as the revenue agency does in many other countries), and in return promised to provide one itself. The free one, it turns out, is not called the \u0026ldquo;Free Edition,\u0026rdquo; but rather the \u0026ldquo;Freedom Edition,\u0026rdquo; and is not reachable from the Turbotax website.\nDark patterns in Facebook Most cases of dark patterns are more subtle. Take Facebook, for example. Suppose Alice posts a photo of Bob, and Carol (a friend of them both) then tags Bob in the photo. This seemingly innocent action has an unexpected and pernicious consequence: it makes the photo visible to all of Bob\u0026rsquo;s friends, even those who are not friends of Alice or Carol. Perhaps the photo shows Bob at a job fair talking to a competitor and his friends include his work colleagues. There are all kinds of reasons that Bob might not want the photo to be shared in this way.\nNow Facebook would likely respond that its users should know how the app behaves, and that they are free to choose more stringent privacy settings. Bob could have turned on a \u0026ldquo;tag review\u0026rdquo; setting that would have required his approval before the photo was shown to all his friends. In practice, of course, most users don\u0026rsquo;t have a clue what\u0026rsquo;s going on, or how to change their settings. And not surprisingly, the defaults seem to favor Facebook rather than its users.\n(I\u0026rsquo;ve written a piece for a lay audience about how Facebook uses \u0026ldquo;dark concepts\u0026rdquo; to further its sometimes nefarious business practices: you can find it here.)\nThe key idea Here\u0026rsquo;s our idea. What\u0026rsquo;s wrong with simple UI dark patterns is that they confound the expectations of the user: you think that big green button is the normal approval of your purchase, but it turns out to be the one that signs you up with extra insurance that you didn\u0026rsquo;t want to buy. Patterns that operate more deeply also confound expectations, not about the meaning of user interface widgets, but about the very behavior of the concept at hand. When you see a familiar concept like a shopping cart, you bring with you all your prior experiences of shopping carts, so you assume this shopping cart will be no different. You don\u0026rsquo;t expect items to be added to the cart spontaneously without your approval; shopping carts just don\u0026rsquo;t do that.\nThe use of a common concept thus establishes a kind of implicit contract between the company and the consumer. In exactly the same way, if an employee of a supermarket came and dropped items into your cart because they \u0026ldquo;thought you might like them,\u0026rdquo; your grounds for objection should not be that such an action is inherently evil. It\u0026rsquo;s that shopping carts just don\u0026rsquo;t work that way.\nFacebook\u0026rsquo;s concepts Let\u0026rsquo;s apply this idea to Facebook. Our task is to come up with plausible concept definitions that capture our expectations of activities such as posting, friending and tagging. This will not be easy because apps like Facebook are so baroque that arguably our expectations are uncertain and inconsistent. So instead we\u0026rsquo;ll try to imagine how an app like Facebook might work if it were designed to be as simple and clear as possible.\nOur first task is to identify the essential concepts, and assign each a compelling purpose and a role with respect to privacy. For example, we might come up with the following concepts and purposes:\nPost: author content Comment: respond to content by others Friend: control access to your content Tag: identify users in images Even these apparently simple purposes are not uncontentious. The Friend concept, for example, is also used to filter content (so that you see content that you\u0026rsquo;re interested in). This purpose arguably belongs to the Follower concept, however, which in Facebook is merged into the Friend concept. But this issue need not bother us here, since privacy is our primary concern.\nNow let\u0026rsquo;s assign privacy roles to concepts:\nPost: determines who can edit content (the author) Comment: determines who can edit response (its author) Friend: determines who can see content (friends of the content publisher) Tag: no role The privacy roles of Post and Content are straightforward: they control only who can edit the post or the comment (namely the author who wrote them in the first place). Deciding that Tag has no privacy role is obviously inconsistent with the way it behaves in Facebook, but we\u0026rsquo;re laying out the simple case for now. Friend is the interesting one here, and as we\u0026rsquo;ll see, what\u0026rsquo;s tricky is defining who publishes given content.\nAs we enumerate these concepts and their roles, we realize that we have covered reading and editing (and implicitly creating, assuming that each concept governs the creation of its namesake items), but not deletion. So we add one more concept\nOwner: manage deletion of items that will determine who is allowed to delete which items.\nDefining states Our next task is to outline the behavior of the individual concepts. The interesting case is Friend. We start with the state components (aka the data model):\npublishes: User -\u0026gt; set Item friends: User -\u0026gt; set User sees: User -\u0026gt; set Item = friends.publishes The publishes relation will track which items have been published by which users. Note that I wrote Item and not Post or Comment or Tag. No concept should depend on the existence of any other; we should be able to understand Friend without knowing what form the items that are published will take. From Friend\u0026rsquo;s point of view, only the identity of an item matters, and Item can be viewed as a type variable (so that Friend is generic over all possible items).\nNote also that the Friend concept maintains its own record of which item was published by which user; it can\u0026rsquo;t refer to a relation in some other concept (such as which items are owned by which users in the Owner concept, or which posts are authored by which users in the Post concept). This might seem to be redundant, but in fact it isn\u0026rsquo;t: we\u0026rsquo;ll see that the publishes relation does not neatly align with these other relations in the other concepts. You can own an item but not publish it, for example.\nFinally, the sees relation defines which items a particular user can see. It is not a state component that can be independently updated, but is instead defined in terms of the other state components. The expression friend.publishes uses the Alloy join operator, and associates with a user the set of items published by that user\u0026rsquo;s friends.\nDefining actions To complete the behavior of the individual concepts, we define actions. For Friend, for example, we might have the following actions, each with a comment giving its effect on the state:\npublish (u: User, i: Item) // add i to u.publishes friend (u, u’: User) // adds u to u’.friends and vv unfriend (u, u’: User) // removes u from u’.friends and vv read (u: User, i: Item) // blocks unless i in u.sees delete (i: Item) // remove item Of course these specs can be written precisely in a language like Alloy and—in addition to being precise—that would let you do automatic simulation and analysis. But that\u0026rsquo;s a story for another day. The important things to note here are: (a) that the read action is a kind of placeholder; it doesn\u0026rsquo;t really do anything except block if the user isn\u0026rsquo;t allowed to see the item; and (b) that the publish action is not called \u0026ldquo;post\u0026rdquo; or anything that like, because it will be in the composition with other concepts that we get to decide what comprises publishing.\nDefining synchronizations Now we can put things together, and define the overall behavior by synchronizing the actions of the individual concepts. I\u0026rsquo;ve only shown you the actions of the Friend concept, but I think you\u0026rsquo;ll be able to figure out what the actions of the other concepts do from their names.\nHere are two synchronizations:\napp fb includes Post, Comment, Tag, Owner, Friend, … // when user u adds a comment c to post p sync Comment.add_comment (u, p, c) // the author of the comment becomes its owner Owner.create (u, c) // the owners of the post become owners of the comment Owner.add_owners (p.(Owner/owners), c) // the comment is published by the publisher of the post Friend.publish (p.(Friend/publishes), c) // when user u adds tag t to item i for user m sync Tag.tag (u, m, t, i) // creator of tag becomes owner Owner.create (u, t) // mentioned user becomes owner too, so can delete Owner.add_owners (t, m) // tag itself is published by publisher of item Friend.publish (i.(Friend/publishes), t) The first one describes what happens when the user adds a comment. That action produces three additional actions: the user who adds the comment becomes an owner of the comment; the owners of the post (on which the comment is made) become owners of the comment; and the comment is published by the publisher of the post. The expression p.(Friend/publishes) uses Alloy\u0026rsquo;s nifty dot operator to navigate backwards from the post p through the publishes relation in Friend to obtain the set of users that are the publishers of p.\nAs a result of these actions, when Alice adds a comment to Bob\u0026rsquo;s post, only Alice can edit the comment (since authorship is maintained in the Comment concept); both of them can delete the comment (since they are both owners, and the Owner concept lets owners delete items); and the comment is deemed to have been published not by Alice but by Bob. This last part is critical for our exploration of privacy in Facebook: it\u0026rsquo;s what ensures that it\u0026rsquo;s Bob\u0026rsquo;s friends, and not Alice\u0026rsquo;s friends, who see the comment.\nThe second sync says what happens when a user tags an item. Both the tagger and the tagged person are owners, so the tagged person can delete the tag if they don\u0026rsquo;t like it. More interestingly, the effect of tagging includes making the tag published by the publisher of the item. So this means that the tag is visible to the same set of users as the item it\u0026rsquo;s attached to.\nModeling the way Facebook really is This is not how Facebook works by default, although you can get this behavior by tightening your privacy settings. Here is a sync that describes Facebook\u0026rsquo;s default behavior:\n// when user u adds tag t to item i for user m sync tag.tag (u, m, t, i) ... // owners as before // tag itself is published by publisher of item friend.publish (i.(Friend/publishes), t)\t// tagged person becomes a publisher of the item friend.publish (m, i)\t// tagged person becomes a publisher of the tag friend.publish (m, t) In this variant, the person tagged (m) additionally becomes a publisher of both the tag and the item tagged: that means that all their friends will see the tagging.\nWhat have we gained? By describing the Facebook design in terms of concepts, we\u0026rsquo;ve achieved a few things:\nWe\u0026rsquo;ve factored the behavior into understandable pieces. In particular, the Friend concept is responsible for managing visibility, and encapsulates a very simple rule: you can see what your friends publish.\nBecause concepts can be combined by synchronization, we can describe behaviors in which actions happen not only because they are directly initiated by the user (such as adding a comment), but also because they occur implicitly, in combination with other events (such as the publishing of the comment by the author of the associated post).\nWe can now disentangle things, When Alice tags Carol in Bob\u0026rsquo;s post, who is publishing what? In the design we proposed as the sane one, Bob is the publisher of the tag, just as he would be the publisher of a comment that Alice made on his post. And thus the audience of the post is not expanded by the act of tagging. In contrast, in the Facebook design, when Alice tags Carol in Bob\u0026rsquo;s post, Carol is deemed to be publishing not only the tag but also the original post!\nWe can now judge the various design options, distinguishing sane and straightforward designs from those that are at best baroque and at worst malicious. For example, the case for arguing that any follow-up to a post is treated as published by the author of the post is straightforward, and corresponds to the idea of the whole discussion being \u0026ldquo;hosted\u0026rdquo; by that author. The case for the actual Facebook design, in which a tagged person is deemed to republish the post as a whole, seems much harder to defend.\nWhere does this all go? The upshot of this rather lengthy (and in places complicated) discussion can be stated simply. A user interacts with a software system by executing a series of actions. In an honest design free of dark patterns, which actions occur, and the effect of those actions, align with the user\u0026rsquo;s expectations. Those expectations are set by the assumptions that the user brings to the interaction, based on prior experiences with similar systems. They include simple expectations about the user interface itself (for example, that green means go and red means stop), and deeper expectations about the underlying functionality (for example, that items don\u0026rsquo;t spontaneously get added to a shopping cart). Concepts provide a way to identify recurring units of functionality, and thus to articulate these assumptions.\nThese ideas could be used to make apps such as Facebook more transparent and accountable to their users. An industry standards body could agree on the definition of concepts such as Friend, and Facebook would then be encouraged (or perhaps required) either to conform to that concept, or make it very clear that their concept was not compliant. Along with this, Facebook would be required to explain in simple terms who is publishing what, so that a user can figure out how actions in other concepts are interpreted as publishing actions from the point of view of Friend.\nAdmittedly, this isn\u0026rsquo;t simple. But it\u0026rsquo;s surely simpler than the status quo, in which the user is faced with a complex data model of posts, comments, replies, tags and friends, and very little structure that would allow them to understand what\u0026rsquo;s really going on.\nThis post has been edited, based on very helpful discussions with Rebecca Jackson and Eunsuk Kang. Thank you to both of them. Thank you also to Jimmy Koppel for pointing me to Joel Spolsky\u0026rsquo;s story in which he experienced \u0026ldquo;sneak into basket\u0026rdquo; in a physical store.\n","permalink":"https://essenceofsoftware.com/posts/facebook/","summary":"What\u0026rsquo;s really going on with dark patterns?","title":"Facebook and Dark Patterns"},{"content":"Basic sys admin tasks can be surprisingly hard. You find some magic incantations online, which you dutifully type into a terminal, but then they don\u0026rsquo;t have the desired effect. What now? At that point, you\u0026rsquo;re usually stuck with no recourse (except to start an endless descent into online forums).\nI had this experience recently trying to install Jekyll, a static website generator. Despite trying for a few hours, I just couldn\u0026rsquo;t do it. So I switched to Hugo, a similar tool that offers an executable image so you don\u0026rsquo;t have to build it yourself. Downloading a file and executing it is fortunately something I\u0026rsquo;m capable of doing (although even that has become harder with Apple\u0026rsquo;s security protections).\nWhy are these simple tasks often so challenging? In large part, it\u0026rsquo;s because the underlying concepts are both complicated and fragile, so you need to know a lot—and understand them more deeply than should be necessary— to work around their rough edges.\nDNS and DKIM Here\u0026rsquo;s an example, involving two concepts—one you\u0026rsquo;re probably familiar with and one that might be new to you. The first is domain name resolution, and is the central concept of DNS (the Domain Name System). Its purpose is to decouple long-lasting domain names from the ephemeral machine addresses that serve them. The operational principle, roughly, is that the owner of a domain provides the domain name and an IP address, and subsequent lookups for that domain resolve to that IP address. The concept works hand-in-hand with the domain registration concept, which manages the process by which an owner acquires a domain (along with permission to update its DNS records), and the concepts corresponding to the various protocols that use DNS, such as http.\nThe second is domain keys identified mail (DKIM), a concept whose purpose is to reduce email spoofing. The operational principle is that the owner of a domain signs the from-address of an outgoing email message (along with some other fields from the email header) with the domain\u0026rsquo;s private key, and places the signature in the header; the recipient then uses the domain\u0026rsquo;s public key to check the signature, rejecting the message if the check fails. Assuming no other server has access to the domain\u0026rsquo;s private key, this ensures that only the legitimate servers of that domain can successfully sign messages, and messages that purport to come from that domain but are actually spoofing the from-address will be rejected.\nGetting the Key How does the recipient obtain the domain\u0026rsquo;s public key? It could send a request to the outgoing email server, but that would require the server to support a special protocol. Instead, the key is stored as a DNS record. In addition to the records used for the domain name resolution concept, the domain name system includes a special \u0026ldquo;TXT\u0026rdquo; record type that is used to hold protocol-specific details associated with a domain. Thus a domain owner can create a record for DKIM that holds the DKIM public key.\nTXT records have proliferated with the growth of new applications. Unfortunately, the DNS query that returns TXT records returns all the TXT records associated with a domain, and the recipient has to sort through them to find the relevant record. For this reason (and others), a new approach has become popular, in which the DKIM key is placed not in a TXT record, but in a CNAME record. CNAME, which stands for \u0026ldquo;canonical name\u0026rdquo; is a form of record used for domain name aliasing: it lets you map one host name within your domain to another. It is commonly used, for example, to redirect a name such as www.dnj.photo to dnj.photo.\nSo how is this done? Here\u0026rsquo;s the trick. You create a CNAME record that maps a name like s1._domainkey.foo.com to the name of a host that, when queried, will provide the DKIM key (thus also introducing a useful layer of indirection, so you can change the DKIM key without changing the DNS record). In this name, s1 is called a \u0026ldquo;selector\u0026rdquo; and is used by DKIM to select one key over another (so that you can rotate keys for example, or have different keys for different email services), and foo.com is the email-sending domain that is being authenticated. The funny part is _domainkey. That\u0026rsquo;s an actual string, not a placeholder, and its purpose is to ensure that the whole name is interpreted as a label for a DKIM key, and not as a regular domain name.\nUnderscoring the Problem This tactic risks polluting the namespace of your domain, and that\u0026rsquo;s why the DKIM designers included the underscore. Perhaps you have a host name called domainkey, but surely you wouldn\u0026rsquo;t want a host name that starts with an underscore? In fact, underscores cannot appear in host names according to IETF standards. But then, since CNAME records map host names, shouldn\u0026rsquo;t an underscore be prohibited there?\nRFC2181 attempted to clarify this issue, insisting that DNS is a general database, and is not just for domain name resolution, and the names that appear as labels in DNS records can thus be arbitrary strings. That\u0026rsquo;s all very well, but it\u0026rsquo;s not consistent with the intended role of CNAME records, which is precisely to map host names! Another article noting this confusion explains that \u0026ldquo;there are many DNS entries that are not host names,\u0026rdquo;\u0026quot; which seems to imply that CNAME records, whose labels generally are host names, should indeed be excluded from the looser rule.\nNot surprisingly, some DNS providers reject underscores in CNAME records, and this means that if your mail service needs DKIM keys to be stored in CNAME records, you\u0026rsquo;re hosed. ()\nWhat\u0026rsquo;s going on here? In short, to support DKIM, the domain name resolution concept has been overloaded. This is a form of overloading I call \u0026ldquo;piggybacking\u0026rdquo; in my book, in which a developer wanting to add some function finds some existing concept to support it, even though it doesn\u0026rsquo;t quite fit.\nHere, the new function is using DNS for mapping application-specific attributes to values. By squeezing this functionality into the existing domain name resolution concept, and the CNAME record in particular, we now have a mess in which some \u0026ldquo;host names\u0026rdquo; aren\u0026rsquo;t in fact names of hosts, and DNS providers differ on how they interpret the rules about whether such a name can have an underscore.\nWhat\u0026rsquo;s the alternative? Instead of piggybacking, DNS might have been extended with a new concept, allowing lookups in which you give a domain name (foo.com) and an application-specific attribute (dkim, say), and the DNS server returns the associated value (the DKIM public key). A new standard for TXT records could support such a concept.\nNo Big Deal? Now you might say that I\u0026rsquo;m making a mountain out of a molehill, and that these are small complications. But in practice, it\u0026rsquo;s a mass of small, self-inflicted wounds of this sort that make many systems so complex and fragile. It turns out that DKIM—as well as SPF and DMARC, the other protocols used to prevent mail spoofing—can often be broken by hackers, because of exactly this kind of non-uniformity (for example, in parsing email addresses).\nPiggybacking will always seem cheaper and easier than modifying a concept or creating a new one. But the eventual price may be much higher.\nFrom my newsletter: archives and signup here.\nUpdate A few updates and corrections, following some further investigation and input from DNS experts:\nDNS as a general database. The earliest RFCs mention DNS holding information beyond host addresses—including phone numbers for CSNET, for example—and make it clear that the resource records were not to be limited to the initial types. It wasn\u0026rsquo;t until later, though, that the idea of DNS as a general key/value store seems to have emerged explicitly. Jerry Saltzer, who developed a name service for Athena at MIT called Hesiod, told me that Paul Mockapetris added the TXT resource type to support more general lookups, as required by applications such as Hesiod.\nDomain names as intentional names. Domain names that included property labels go back at least to Hesiod, which used an @-symbol to separate the property-specifying part from the rest, eg. finger-server@berkeley.mit.edu. A project at MIT in 1999 explored this general idea, in which a name does not designate a service directly, but rather specifies the properties for a desired service, and called it intentional naming. In 2000, RFC 2782 described the addition of the SRV resource type, which mapped domain names of the form _service._protocol.name to server/port names, allowing intentional names such as _ldap._tcp.foo.com.\nDomain names that include property keys. A domain name like domainkey.foo.com is not an intentional name that specifies a service. The DKIM protocol does not require a service; all that\u0026rsquo;s needed is for the DKIM key to provided for the domain. Instead, this domain name is a combination of a domain name (foo.com) and a key to be looked up in the DNS records of that domain name.\nUnderscores in domain names. The use of underscores in these extended forms of name prevented conflicts with hostnames, but introduced the new risk of the new labels conflicting. In 2019, RFC 8552 described the convention of naming with underscored labels, and introduced a registry to avoid collisions.\nUnderscore confusions. The early RFCs said that domain names should be as general as possible, but confusing wording misled many people. A much-quoted statement from RFC 882 seems to say that underscores are not permitted in the labels that comprise domain names: \u0026ldquo;The labels must follow the rules for ARPANET host names. They must start with a letter, end with a letter or digit, and have as interior characters only letters, digits, and hyphen.\u0026rdquo; This statement, however, seems on closer reading to be an informal explanation for a grammar that is not intended to be mandatory: \u0026ldquo;The preferred syntax of domain names is given by the following BNF rules. Adherence to this syntax will result in fewer problems with many applications that use domain names (e.g., mail, TELNET).\u0026rdquo; This complicated position is elaborated in RFC 1035 which states:\nThe DNS specifications attempt to be as general as possible in the rules for constructing domain names. The idea is that the name of any existing object can be expressed as a domain name with minimal changes. However, when assigning a domain name for an object, the prudent user will select a name which satisfies both the rules of the domain system and any existing rules for the object, whether these rules are published or implied by existing programs.*\nNot surprisingly this has confused even experts; a ballot amongst a consortium of companies voted to sunset the use of underscores in DNS names appearing in certificates, citing the statement in 1035 that \u0026ldquo;labels must follow the rules for ARPANET host names\u0026rdquo; which it took, incorrectly, to specify \u0026ldquo;the characters which may be used in DNS domain names.\u0026rdquo;\u0026quot;\nCNAME records for DKIM. Use of CNAME resource records for DKIM is not (I believe), as I originally suggested above, to avoid the use of TXT records, but rather to provide an extra level of indirection so that a domain can delegate to a hosting service the job of assigning (and rotating) DKIM keys. The use of the _domainkey prefix alone would limit the number of TXT records returned, since the extended domain name has a different set of resource records associated with it than the base domain name.\nRefining the concept design analysis. In summary, there are (at least) three distinct concepts in play here. First there is the concept of a HierarchicalName, which allows a name space to be divided into separately managed zones. This concept is familiar from file systems, and from the structure of many web APIs (which use so called \u0026ldquo;RESTful\u0026rdquo; names for resources). Second is the concept of IntentionalName, in which a name becomes a kind of specification. This also existed prior to DNS, although the concept has been less widely adopted. Third is the concept of Metadata in which an object has a collection of properties associated with it; a photo, for example, has its capture time and exposure; a file has its creation time; a DNS domain has its domain key.\nThe lens of concept design helps us recognize that much of the richness of DNS that we have explored comes from the fact that three distinct concepts are being offered. The familiarity of these existing concepts should make DNS easier to understand.\nWhat is unusual is that all three concepts are implemented by the same mechanism. In concept lingo, the second and third concepts are \u0026ldquo;piggybacked\u0026rdquo; onto the first concept, with the properties and specifiers of Metadata and IntentionalName respectively both represented as labels in a prefix of a domain name. Like many piggybacking designs, this is ingenious and solves some problems. In particular, it allowed DNS itself to remain unchanged, without the need for new resource types or mechanisms (although it did require the creation of a new registry to avoid name clashes).\nThe downside is that piggybacked concepts generally cannot be fully supported by a mechanism that was not designed for them. A full implementation of IntentionalName, for example, would allow wildcard specifiers, so that for example one could request not only a color printer _printer._color.local.foo.com or a monochrome printer _printer._mono.local.foo.com but also any printer _printer.*.local.foo.com whether color or monochrome. As noted in RFC8552, DNS cannot support such wildcards. Another price paid for the piggybacking is some additional complexity involved in squeezing the new functionality into a Procrustean bed—here, the underscore, and all the confusion created about whether it is permitted.\nWhether the DNS design is bad or good is not the main issue here—and now I have a better appreciation of the tradeoffs I am less inclined to insist that this piggybacking is a mistake. What my analysis shows, I hope, is that concept design can reveal the underlying issues and make clearer whatever tradeoffs are being made.\n","permalink":"https://essenceofsoftware.com/posts/dns-dkim/","summary":"Or why basic sysadmin tasks are so hard.","title":"Concept Piggybacking in DNS"},{"content":"I\u0026rsquo;m always excited to find examples outside software that concept design can be applied to. Here\u0026rsquo;s one I came across this week.\nAs part of a restructuring of our curriculum, we\u0026rsquo;re fixing up our class numbers. Currently, our programming sequence looks like this:\n6.0001 Introduction to CS and Programming using Python 6.009 Fundamentals of Programming 6.031 Software Construction 6.170 Software Studio After renumbering, it might become:\n6.100 Introduction to CS and Programming using Python 6.101 Fundamentals of Programming 6.102 Software Construction 6.103 Software Studio Surprisingly, making such a change actually turns out to be really hard. One major problem is that (because we have a large department with many classes) this would require reassigning some existing numbers. But MIT\u0026rsquo;s registrar has a rule that you can\u0026rsquo;t reassign a class number unless it has been unused for five years!\nWhat\u0026rsquo;s going on here? The concept of class number has multiple, conflicting purposes: in concept lingo, it\u0026rsquo;s overloaded. One purpose is to be a shorthand that signals the role that the class plays in degree requirements. This includes the level of the class (thus hinting that 6.101 would be taken before 6.102) and, in the case of our renumbering, also the general area the class belongs to (thus 6 says it\u0026rsquo;s a class in EECS, and 6.1 that it\u0026rsquo;s in the software track).\nThe other purpose is that the number acts as a name that persists from term to term (so students and prospective employers can assume that 6.103 is consistent from year to year, for example). It\u0026rsquo;s because of this second purpose that the registrar forbids reassignment of numbers without a five-year gap.\nWhat\u0026rsquo;s the solution to this dilemma? The standard concept design move would be to split into multiple concepts, one for each purpose. We could add a mnemonic name (or commandeer the course title) to serve the naming purpose, and reserve the number for signaling the place in the curriculum. So then we might have, for example:\n6.100 Software Intro 6.101 Software Fundamentals 6.102 Software Construction 6.103 Software Studio Is this a reasonable solution? I\u0026rsquo;m not sure. It would require a culture change at MIT to refer to a class by a name (\u0026ldquo;software studio\u0026rdquo;) rather than a number (\u0026ldquo;103\u0026rdquo;). On the other hand, encouraging more mnemonic names might be a good thing and would help beyond the university: I remember that Tim Nelson\u0026rsquo;s class that teaches Alloy at Brown is called \u0026ldquo;Logic for Systems\u0026rdquo; and not that its number is \u0026ldquo;CSCI 1710\u0026rdquo;. And the alternatives are not much better. One ingenious proposal is to satisfy the registrar\u0026rsquo;s rule by appending a zero to each number, and then remove it after five years.\nI wonder if there\u0026rsquo;s a better conceptual solution. Let me know if you can think of one!\nFrom my newsletter: archives and signup here.\n","permalink":"https://essenceofsoftware.com/posts/class-numbers/","summary":"Who knew such a simple thing could be so challenging?","title":"The Class Number Dilemma"},{"content":" This article summarizes the key ideas in the book The Essence of Software. It is not intended to be understandable by itself. It gives almost no examples, makes claims without justifying them, and cites almost no related work. And it\u0026rsquo;s not nearly so much fun to read as the book :-). But, hey, at least it\u0026rsquo;s short(ish)!\nIf you haven\u0026rsquo;t read the book, I recommend that you don\u0026rsquo;t start with this, but watch my ACM talk instead. But perhaps you don\u0026rsquo;t really want to read the book, and just want to be able to hold your own at a cocktail party showing off your sophistication in software design. In that case, this may be for you.\nIf you\u0026rsquo;ve read the book, this summary should be a useful reminder of the key ideas, to help you solidify them in your mind and relate them to other approaches. In this sense, it augments the shorter list of provocative questions in Chapter 12 of the book.\nA final warning before you jump in: this summary assumes a fairly extensive background in software design and development. The book itself is aimed at a broader audience, introduces the ideas more gently by way of example, and relegates the harder technical stuff to end notes.\nDefining Software Design In most fields, \u0026ldquo;design\u0026rdquo; means shaping an artifact to meet the needs of users, thus sitting at the boundary between humans and machines. Despite Kapor\u0026rsquo;s notable manifesto in 1990, and the book edited by Winograd that followed in 1996, little attention has been paid to software design.\nEnormous effort, in contrast, has been devoted to software engineering (whose interest instead is software\u0026rsquo;s internal structure and means of construction). This disparity of attention has resulted in great advances in programming, represented by a major body of knowledge and well-known design principles.\nThe field of human-computer interaction has likewise produced an impressive body of knowledge about user interfaces and how they shape the way we understand and use software. But for software design, where the focus is on the fundamental abstractions that underlie both the interface and the implementation, our knowledge is much more limited, and we have had to be content with being guided instead by vaguer notions, and (albeit sensible) appeals to simplicity and clarity.\nThe Book\u0026rsquo;s Aims and Approach The aims of the book are to highlight a central aspect of software design; to lay out a way to structure and express software designs from this perspective; to provide some heuristics and principles for design; and, more generally, to inspire a renewed focus on software design as a discipline.\nThe book is driven by examples drawn from over 100 apps. By focusing on widely used software produced by the best companies, it seeks to show that serious problems are rife, and challenge even the most talented developers, and that the book\u0026rsquo;s ideas and techniques apply to real software.\nThe book presents a design approach comprising simple textual and diagrammatic notations, a collection of readily applicable heuristics, and some deeper principles. In order to explain the approach in more detail, and to show how it differs from many prior approaches, a collection of end notes is included covering topics from design thinking to formal methods.\nThe Problem Software is harder to use than it needs to be. We spend an increasing portion of our lives engaged with software apps and systems, so improving the design of software impacts the quality of our lives and our ease of working effectively together.\nAs software becomes an ever more critical part of our civic infrastructure, we rely on apps and systems to behave predictably and reliably. A high proportion of failures are due to user errors, for which poor design is usually to blame. And even when a failure is attributed to a bug in the code, it is likely that the bug is due to lack of clarity in design (rather than a simple failure to meet a specification).\nLack of clarity in software design also makes software harder to build, and leads to degradation over time as accretions to a codebase compromise its modularity yet further.\nLevels of Design Software design activities and criteria can be assigned to three levels: physical, which concerns the choice of colors, type, layout, etc, and is influenced by particular human anatomical and cognitive capabilities; linguistic, which concerns the use of icons and labels, terminology, etc, and is dependent on shared cultural and linguistic assumptions; and conceptual, which concerns the underlying semantics of the application, including the actions that can be performed and the effects they have, and the structure and interpretation of the state as viewed by the user.\nThe conceptual level is the most fundamental; different physical and linguistic designs for an app might be equally effective, but even small changes to the conceptual design are usually very disruptive to users. Users\u0026rsquo; problems with apps arise more often from incorrect conceptual understandings than from an inability to interpret the physical and linguistic signals of the user interface.\nThis is due in part to the great advances that have been made in the last decades at the physical and linguistic levels. Many books and online collections of heuristics teach user interface design very effectively, and given also that many client-side frameworks now provide professionally designed widgets, there is little excuse nowadays for a design that fails at these levels.\nPrior Work on Conceptual Design The importance of the conceptual level has been recognized for more than half a century. From early on, researchers noted the importance of a user\u0026rsquo;s \u0026ldquo;mental model\u0026rdquo;, and the need for the design to construct such a model explicitly, so that the user\u0026rsquo;s model and the system model coincide. Fred Brooks coined the term \u0026ldquo;conceptual integrity\u0026rdquo; and argued that the conceptual aspects of software design represented the essence of the field, as opposed to the accidental aspects, to which he relegated the concerns of \u0026ldquo;representation.\u0026rdquo; The fields of conceptual modeling, domain modeling and formal methods all emphasized the centrality of an abstract model of state (and, in the case of formal methods, also behavior) in the design of software.\nAnd yet none of these fields expressly addressed the problem of designing the conceptual structure of software in order to meet the needs of the user and to align the user\u0026rsquo;s understanding. Formal methods focused primarily on the problem of correctness, and ensuring conformance of the implementation to the model. Conceptual modeling and domain modeling focused primarily on the representation of knowledge about the context of operation of a system, rather than on the structures that the designer invented.\nMost curiously missing was a well defined notion of \u0026ldquo;concept.\u0026rdquo; Even in the field of conceptual modeling, there is no shared understanding of what a concept might be, or even well-known candidate definitions. An entire conceptual model seems to be too large to count as a single concept, and its constituent entities (or classes or objects) are too small, especially since an informal understanding of a concept tends to involve relationships amongst multiple elements.\nA New Definition of Concept A concept is a reusable unit of user-facing functionality that serves a well-defined and intelligible purpose. Each concept maintains its own state, and interacts with the user (and with other concepts) through atomic actions. Some actions are performed by users; others are output actions that occur spontaneously under the control of the concept.\nA concept typically involves objects of several different kinds, holding relationships between them in its state. For example, the Upvote concept, whose purpose is to rank items by popularity, maintains a relationship between the items and the users who have approved or disapproved of them. The state of a concept must be sufficiently rich to support the concept\u0026rsquo;s behavior; if Upvote lacked information about users, for example, it would not be able to prevent double voting. But the concept state should be no richer than it need be: Upvote would not include anything about a user beyond the user\u0026rsquo;s identity, since the user\u0026rsquo;s name (for example) plays no role in the concept\u0026rsquo;s behavior.\nConcept Reuse and Familiarity Most concepts are reusable across applications; thus the same Upvote concept appears for upvoting comments in the New York Times and for upvoting answers on Stack Overflow. A concept can also be instantiated multiple times within the same application.\nThis archetypal nature of concepts is essential. From the user\u0026rsquo;s perspective, it gives the familiarity that makes concepts easy to understand: a user encountering the same context in a new setting brings their understanding of that concept from their experience in previous settings.\nFrom a designer\u0026rsquo;s perspective, it allows concepts to be repositories of design knowledge and experience. When a developer implements Upvote, even if they can\u0026rsquo;t reuse the code of a prior implementation, they can rely on all the discoveries and refinements previously made. Many of these are apparent in the behavior of the concept itself, but others are associated with the implementation, or are subtle enough to need explicit description. The community of designers could develop \u0026ldquo;concept catalogs\u0026rdquo; that capture all this knowledge, along with relationships between concepts (for example, that Upvote often relies on the Session concept for identifying users, which itself is associated with the User concept for authenticating users).\nConcept Independence Perhaps the most significant distinguishing feature of concepts, in comparison to other modularity schemes, is their mutual independence. Each concept is defined without reference to any other concepts, and can be understood in isolation.\nEarly work on mental models established the principle that, in a robust model, the different elements must be independently understandable. The same holds in software: the reason a user can make sense of a new social media app, for example, is that each of the concepts (Post, Comment, Upvote, Friend, etc) are not only familiar but also separable, so that understanding one doesn\u0026rsquo;t require understanding another.\nConcept independence lets design scale, because individual concepts can be worked on by different designers or design teams, and brought together later. Reuse requires independence too, because coupling between concepts would prevent a concept from being adopted without also including the concepts it depends on.\nPolymorphism is key to independence: the designer of a concept should strive to make the concept as free as possible of any assumptions about the content and interpretation of objects passed as action arguments. Even if a Comment concept is used within an app only for comments on posts, it should be described as applying comments to arbitrary targets, defined only by their identity.\nPushing polymorphism as far as possible is a useful strategy: for getting to the essence of a concept; for finding other opportunities to use a concept within the same app (and in other apps); for discovering that what appears to be an app-specific concept is actually a general and familiar one; and, when it\u0026rsquo;s not possible, for identifying concept subtleties or design flaws.\nConcepts can be implemented independently also; in the Deja Vu platform, Santiago Perez De Rosso showed how apps could be constructed by glueing together reusable, full-stack concepts drawn from a library.\nA Structure for Describing Concepts To work with concepts, we need a simple structure for describing them. A concept is defined by its behavior, which comprises its state space and a set of actions. These can be defined using standard methods and notations.\nFor defining the state space, a data model is given that consists of a collection of components, each of which is a scalar/option, set or relation (of any arity). This model can be recorded with textual declarations or as an extended entity-relationship diagram. The details of the data model are not fundamental to concepts, and different models could be used. What is important is that the state of a concept is (by default) visible to users, so states should make sense to users (and at the very least should be defined explicitly in the spirit of \u0026ldquo;model-based specification\u0026rdquo; rather than implicitly by algebraic axioms).\nActions can be initiated by the user or by the system, and a single action can have both inputs and outputs. A single action can abstract what would be an entire use case in object-oriented modeling approaches, allowing a much terser form of description. An action can also abstract away (that is, not represent in detail) the creation of complex inputs; for example, an action input may be a rich-text object that in the implementation would be produced by an extended interaction with a rich-text editor.\nActions read and write states. An action may have a precondition that makes it applicable only in certain states; when the precondition does not hold, the action is blocked and may not occur. Actions can be non-deterministic, resulting in more than one possible outcome for a given pre-state/input combination. But any non-determinism must be exposed in output arguments, so that the state of a concept is always a function of the trace of actions that have occurred so far. For example, an airline reservation concept could have an assignSeat action that picks an arbitrary seat and assigns it to the customer, but the seat must be represented as an output of the action (in addition to appearing in the post-state of the relation that maps customers to seats).\nFrom a data modeling perspective, there is no global data model. Instead, there is a collection of local data models, one for each concept. Each concept\u0026rsquo;s data model is just rich enough to support its actions. (In teaching data modeling, I have found that this makes it much easier for programmers to scope their models. In traditional modeling, it\u0026rsquo;s all too easy to get carried away with building a data model based on ontological observations that are not actually relevant to the design of the system.)\nIf the state and action definitions are written in a formal notation such as Alloy, the concept behavior can be analyzed automatically, with generation of sample executions, comparison of action versions, and checking properties. The modularity that concepts provide amplify the effectiveness of automated analysis. Such analysis is always inherently intractable (the number of executions to check rising super-exponentially with the number of objects in the state), so researchers have always looked for ways to decompose a system into smaller parts. Concepts provide such a decomposition, aligned naturally with the functionality boundaries of the system.\nThe definition of a concept augments this basic behavioral description with two more novel parts explained in more detail below: the purpose and the operational principle.\nConcept Purposes The idea that an artifact should have a purpose distinct from its specification is hardly novel, and many researchers have recognized the importance of purposes, and the impossibility of expressing them fully and precisely (most notably Christopher Alexander in Notes on the Synthesis of Form).\nWhat is novel in concept design is the idea that it is not sufficient for the system or app as a whole to have a purpose (or a collection of purposes). Each concept in its design should have its own purpose. A concept\u0026rsquo;s purpose defines, in a general setting, the reason for its invention and what benefits it offers; in the setting of a particular app, it defines the motivation and justification for including the concept.\nPurposes also clarify subtle distinctions between related concepts. In social media, for example, there are several concepts that may sit behind a \u0026ldquo;thumbs up\u0026rdquo; widget: Upvote, whose purpose is to rank items by popularity so that users (purportedly) see the most valuable content first; Reaction, whose purpose is to convey an emotional reaction to the author of an item; Recommendation, whose purpose is to learn a user\u0026rsquo;s preferences so that subsequent items can be recommended more reliably; and Profile, whose purpose is to track the user\u0026rsquo;s interests in order to target advertising.\nBecause purposes sit at the boundary of the human/computer interface, they cannot be judged formally (the way correctness can, eg). Nevertheless, the book provides criteria for determining whether a purpose is compelling, and when two distinct purposes may be masquerading as one.\nThe Operational Principle A concept definition also includes its operational principle (OP), an archetypal scenario that shows how the concept fulfills its purpose.\nSuperficially, the OP is like a use case, but it plays a very different role. Use cases are a specification notation, and a full spec typically requires many use cases. Use cases are often expressed at a low level too, in terms of the micro-interactions of the user interface (clicking buttons etc). Since a concept\u0026rsquo;s actions fully define its behavior, nothing more is needed to predict how the concept will behave.\nInstead, the OP captures the dynamic essence of the concept, telling the most basic story about how the concept works. Sometimes the OP is so simple it barely even needs stating: when you add a comment to a post, your comment will subsequently appear along with the post (the OP of the Comment concept). But often the OP is more interesting. It may require two distinct scenarios: when you delete a item, you can restore it from the trash; once you empty the trash, though, it\u0026rsquo;s gone forever and its space is reclaimed (Trash). It may need to be quite elaborate in order to demonstrate the purpose and distinguish the concept from similar but less powerful concepts: if you assign a style to two items, and then you update the style, both items will be updated in concert (Style). And it may involve multiple users: after users have upvoted items, the items will be ranked by the number of times they were upvoted (Upvote).\nThe OP may also be aspirational, applying only in ideal circumstances (even if they are typical). It is not true that if you reserve a restaurant table, and then turn up, a table will necessarily be available (since guests at your table may have stayed longer than expected); nor that a successful authentication associated with a user account must have been performed by the same user that registered the account (since someone may have stolen your password). Like many aspects of concepts, the OP may appear to be obvious until you consider things more deeply.\nThe OP often provides the clearest way to explain a concept. To use the PORT elevator system, a rider selects their destination floor on the device in the lobby, which responds with the identifier of the lift car to be taken; the rider enters that car and is taken to their floor. This is complicated enough—and different enough from standard elevators—for the maker (Schindler) to advertise that it\u0026rsquo;s \u0026ldquo;as easy as 1-2-3\u0026rdquo; (namely involves an OP with multiple steps).\nParadoxically a full behavioral description is often less helpful, since (a) it fails to distinguish the essential aspects of the concept design (how style updates effect items) from more arbitrary design decisions (what happens when a style is deleted); and (b) it conveys the motivation for the behavior. For Michael Polanyi, from whose work the idea of the OP is taken, this latter consideration is the key to understanding the difference between design/engineering on the one hand and science on the other (put bluntly, why physics cannot explain how a clock works).\nConcept Synchronization Within an app, concepts can operate largely without interaction: commenting on posts, for example, may be orthogonal to upvoting them. But often concepts need to be coupled together to achieve the app\u0026rsquo;s goals. For example, it may be problematic for users to edit posts after they have been upvoted (since the upvotes responded to content that may have changed). To mitigate this the upvote action of the Upvote concept could be synchronized with the edit action of the Post concept, to prevent edits after a post has been upvoted or to remove upvotes when a post is edited.\nFor some concepts, synchronization is part of their intended usage. An access control concept is intended to suppress some actions in another concept when the user lacks the right permissions; a subscription concept is intended to react to certain actions by generating subsequent notification actions. In these cases, the concept typically offers \u0026lsquo;placeholder\u0026rsquo; actions that are synchronized with the real actions in other concepts: an access control concept may have an access action, for example, which is then pinned to the action to be controlled in another concept.\nSynchronizations are defined reactively: when an action occurs in one concept, some actions should occur in other concepts. Arguments can be passed between actions, so that synchronization includes data flow. Each synchronization is atomic and happens in its entirety or not at all, so if one of the reactive actions is blocked by its concept, the initial action cannot occur either.\nThis model of communication and interaction is inspired by Hoare\u0026rsquo;s CSP, and can be formalized in its terms. A crucial property of the model is that the behavior of each individual concept is preserved. Synchronization can prevent a concept from executing an action, and it can limit the arguments presented to an action, but it can never cause an action to occur (or an output to be produced) that would not be possible for the concept in isolation. As will be explained below, composing concepts maintains their integrity.\nThe synchronization mechanism is also essential for maintaining concept independence and avoiding the need for one concept to \u0026lsquo;call\u0026rsquo; another. At the code level, composition requires mediators to implement the synchronization; these mediators make reference to the concepts, but the concepts themselves remain free of mutual references.\nSynchronization and Automation Synchronization of concepts is often a form of automation, in which the user is saved the trouble of executing a concept action because it follows execution of an action in another concept automatically. Omission of a desirable automation can be attributed to under-synchronization of an app\u0026rsquo;s concepts: in Zoom, for example, the raised hand concept might be synchronized with the audio muting concept so that participants\u0026rsquo; hands are automatically lowered after they have their turn.\nAutomation preempts the user\u0026rsquo;s manual control and thus, if not configurable, can be problematic. Such automation can be attributed to over-synchronization of an app\u0026rsquo;s concepts: in some calendar apps, deleting in the event concept leads undesirably to declining in the invitation concept.\nSynchronization and Decomposition What an app presents as a single concept may be better understood as a synchronization of multiple component concepts. A hint that such a decomposition is warranted is often found in the presented concept having multiple, conflicting purposes.\nFacebook, for example, appears to offer a \u0026rsquo;like\u0026rsquo; concept, but on closer examination, this concept is a synchronization of several of the concepts described above: Upvote, Recommendation, Reaction and Profile. This synchronization is responsible for some confusions and critical commentary about Facebook\u0026rsquo;s design (notably, that an \u0026lsquo;angry\u0026rsquo; reaction produces a positive upvote—by some accounts counted for more than a simple \u0026rsquo;like\u0026rsquo;). With this decomposition in mind, different design options are easy to see: having separate buttons for \u0026ldquo;I\u0026rsquo;m angry\u0026rdquo; and \u0026ldquo;I want to see more of this kind of post\u0026rdquo;, for example.\nConcept Synergy In most compositions, concepts bring additive value. But in some designs, concepts can take advantage of each other so that one concept achieves its own functionality in part by relying on another concept. This is synergy in the setting of concept design, where the value of putting two concepts together is more than the sum of their individual values.\nAn example is Apple\u0026rsquo;s synergistic composition of the Folder and Trash concepts. By making the trash a folder, the design allows the action of moving items between folders to be used to restore items from the trash. Achieving this synergy is non-trivial, and the book explains its subtle evolution over time.\nAttempted synergies can backfire. A version of Outlook placed system logs (reporting for example on connection failures between client and server) in mail folders as if they were messages, but this led to numerous problems (for example that reports of connection failure could not be delivered to clients if\u0026hellip; connections failed).\nConcept Dependence Diagrams As explained above, concepts are inherently uncoupled and free standing, so they can be understood, designed, evaluated and reused independently. Bringing concepts together in an app does not couple them either, since the synchronization mechanism ensures that each concept will conform to its own behavioral expectations even if its actions are tied to the actions of other concepts. Furthermore, implementation need not introduce any dependencies between concepts.\nThere is a kind of dependence between concepts, however, that is useful to analyze, and that arises in the context of usage in a particular app or system. A concept C1 is said to depend on a concept C2 in an app A when the inclusion of C1 only makes sense if C2 is also present. Note that \u0026ldquo;makes sense\u0026rdquo; doesn\u0026rsquo;t mean that C1 would somehow break if C2 were missing, so there is no traditional software-engineering dependence here. Rather, the dependence reflects an understanding of the role of C1 in A. In a social media app with a Comment concept and a Post concept, for example, Comment might depend on Post because it was included to allow users to comment on posts, and if there are no posts, there\u0026rsquo;s not much point in having comments.\nAs with conventional dependencies, the concept dependence relation can be depicted as a dependence graph or diagram. Dependences have several uses. They determine which orders of explanation of an app\u0026rsquo;s concepts will be intelligible; you\u0026rsquo;d explain posts before comments on posts, for example, They define, implicitly, an entire application family (as the set of subgraphs in which some subset of the concepts appears and a concept never appears without those it depends on). The dependence diagram can thus be used to make scoping decisions about which concepts to include or exclude. Dependencies also suggest a development order: it\u0026rsquo;s better to build Post before Comment, so that comments have targets to be tested on.\nConcept Mapping In an implementation of a concept design, the concepts must be mapped to the user interface, connecting the conceptual level of design to the physical and linguistic levels. Actions might be executed by gestures or button presses, for example, and the states of the concepts will be displayed in various views.\nThe standard techniques and heuristics of user interface design apply directly to concept mapping. The lens of concept design helps focus this work.\nSome concepts present tricky mapping challenges, and good mappings can be part of the design knowledge associated with a concept. For the filtering view in the Label concept, in which a collection of items is filtered by a selected label, for example, it might seem desirable to maintain an invariant that the items displayed are exactly those carrying the label, but this turns out not to be a good idea.\nIn Gmail, the Label concept is used to classify messages, but the user interface shows messages in the context of conversations and associates labels with conversations instead. This mapping design is troubled, and leads to a variety of odd behaviors.\nTesting and Prototyping Are Not Enough A concept design is ultimately evaluated in the context of use, and misfits (in which a design fails to fulfill its intended purpose) are never fully predictable, because they depend on properties of the human environment which may not even be knowable until the design is deployed.\nUser testing offers some limited value, especially for evaluating concept mappings, and for catching egregious flaws, but (unlike real deployment) will rarely encounter the corner cases that are most troublesome in a design. Prototyping is a valuable strategy for exploring candidate designs early on, and indeed many of the practices of design thinking can be fruitfully combined with concept design, and are made more useful by the separation of concerns that concepts offer.\nBut generate-and-test is not a viable method for finding a good design in a large design space, let alone a great design. To do that requires an expert designer who can apply prior knowledge of likely problems and known solutions, often acquired in very different settings. Concepts provide a framework for recording and retrieving such knowledge.\nA note for computer scientists: the known problems of standard concepts are sometimes grounded in technology (eg, the difficulty of achieving consistent views of data in a distributed system) but are more often a result of human behavior (eg, that ticket sales invite scalpers who then drive up prices).\nThe Need for Concept Design Principles Over the last few decades, a rich body of UX design principles has been developed. These include prescriptive adaptations of psychological ideas, such as the Gestalt principles of grouping, which can be used to guide layout design, and James Gibson\u0026rsquo;s notion of affordance, made applicable in user interfaces by Don Norman\u0026rsquo;s principle that affordances should be explicitly \u0026ldquo;signified\u0026rdquo;. Norman\u0026rsquo;s book The Design of Everyday Things introduced several additional principles, such as the idea of \u0026ldquo;mapping\u0026rdquo; (a different usage from concept mapping) in which a user interface mirrors the structure of the domain being controlled. Other pioneers produced explicit collections of principles: Ben Shneiderman\u0026rsquo;s golden rules, Jakob Nielsen\u0026rsquo;s heuristics, and Bruce Tognazzini\u0026rsquo;s principles of interaction design.\nEspecially in the hands of experts, these principles make it possible to design a user interface that is likely to be highly usable, with a low probability of serious usability flaws. Indeed, there is no excuse nowadays for poor user interface design, and user testing is much less important for routine design work (although it\u0026rsquo;s still valuable of course, especially for very novel or critical designs).\nAlmost all of these principles, however, are focused on the physical and linguistic levels of design. New principles are needed at the conceptual level. The book presents three such principles and explains them in detail with many examples from contemporary apps.\nConcept Design Principles Familiarity. When possible, a familiar concept should be preferred to a new, unfamiliar one. With familiar concepts, users can rely on their prior experience, and don\u0026rsquo;t need to learn a concept afresh. And designers can take advantage of the body of knowledge associated with a known concept, reducing the risk of a design with unexpected misfits. The familiarity principle can be seen as an application of a meta principle of consistency: when a purpose arises in an app that has arisen before, the same solution should be used.\nSpecificity. If you draw up a list of the purposes purportedly served by an app, the purposes and the concepts that aim to fulfill them should be in one-to-one correspondence. This implies first that every purpose should have at least one concept that fulfills it, and that every concept has some purpose that motivates it. So much is obvious, although there are examples in real apps (which the book explains) of unhelpful concepts that serve no user purpose, and purposes that are essential to an app that are fulfilled by no concept.\nThe more subtle implications are: no redundancy, namely that each purpose should be fulfilled by at most one concept, and no overloading, namely that each concept should serve at most one purpose. Redundancy is clearly undesirable because it involves a waste of resources (in the designer\u0026rsquo;s work and in the user\u0026rsquo;s understanding). Overloading is a more subtle notion: that a concept that tries to serve multiple purposes is pulled in different directions, and cannot serve any one purpose effectively. This idea is related to the independence axiom in Nam Suh\u0026rsquo;s theory of mechanical design, and to the common observation in programming that each segment of code should have a single goal.\nThe book gives many examples of concepts doomed by overloading, classifying them into different causes for the overloading:\nfalse convergence, when a concept is designed for two different functions that were assumed (wrongly) to be aspects of the same purpose; denied purpose, when a purpose was ignored by the designer, despite the desires of users; emergent purposes, in which new purposes arise for old concepts, often invented by the users themselves; and piggybacking, when an existing concept is adapted or extended to accommodate a new purpose. Integrity. This principle says that when concepts are put together into an app, the each concept should continue to behave according to its (app-independent) concept definition. If concepts are composed by synchronization, integrity will be preserved by design. But if composition is more ad hoc, or if concepts are adjusted to suit the larger context of the app, there is a risk of violation. Google Drive, for example, offers a sync concept (not to be confused with concept sync!) in which local files on disk are kept in sync with files in the cloud. But in an egregious violation of integrity of this concept, only conventional files are properly synced, and files associated with Google Apps (such as Google Docs) are treated specially, and are represented on the local disk not by their contents but by a URL. A lack of awareness of this limitation has been catastrophic for some users.\nComparisons to Other Approaches Concept design builds on more than 50 years of advances in a variety of fields, and contributes some new ideas. First, some work that sounds similar but is not really relevant:\nConcept maps are diagrammatic representations of collections of facts, with each edge representing a proposition that applies a predicate (the label of the edge) to two atoms (the nodes it connects). Concept maps are an application of knowledge graphs; they were proposed as an educational tool. They are \u0026ldquo;conceptual\u0026rdquo; in the sense that predicate logic lets you formalize all kinds of relationships, at any level of abstraction; and since the predicates don\u0026rsquo;t need to be designated (using Michael Jackson\u0026rsquo;s term), they can express ideas that would be hard to nail down precisely. The very flexibility of concept maps seems to limit their leverage in software design.\nConcept lattices are representations of partial orders between classifications, where the order is set inclusion. Classification is a useful activity but is limited in the context of software design because it doesn\u0026rsquo;t address relationships, and is usually static, so does not address behavior.\nAt the other end of the spectrum, the most closely related work is:\nConceptual modeling. The field of conceptual modeling is broad and has many motivations, but part of it is concerned with explicit representations of the structures that underlie both applications and the mental models of users. The emphasis of the field has tended in the direction of ontologies (eg, for reasoning and knowledge representation), or in the direction of domain modeling (eg, for understanding the environment in which a software system operates), and in these respects conceptual structures are usually discovered rather than invented. In contrast, concept design focuses more on concepts as socio-technical inventions that serve a purpose. Most conceptual models are essentially abstract data models (in the spirit of entity-relationship diagrams), although there is work on dynamic models too (although these are hard to distinguish from standard kinds of dynamic models such as Statecharts). What concept design seeks to provide, which seems to be missing from conceptual modeling, is the notion of a identifiable concepts. Without this, there can be no modularity in conceptual models, and it is not possible to talk about concepts as separable contributions, to identify common concepts between models, or to reuse concepts. The terminology of conceptual modeling sometimes seems to imply that the entities of a data model are concepts, but these are not good concepts, since concepts typically involve relationships between objects. Some approaches seek to identify concepts with objects or classes, but this has an implementation flavor to it, since there is rarely a natural way to assign relationships and behavior to a single object or class.\nObjects and classes. In the early days of object-oriented programming and development, the idea that objects naturally mirrored or modeled the real world was seen as a major benefit. Over time, the idea became less plausible, first because object-oriented programming took on more arcane forms moving further away from domain structures (under the influence of the Gang of Four patterns and other advanced programming techniques), and second because the inherent implementation bias in object-oriented design became clearer. The key problem is that, in the real world, the properties and behavior of objects involve relationships between them, and can rarely be satisfactorily assigned to individual objects. In practice, this is usually addressed by defining objects that hold relationships between other objects, but such a style is not really object-oriented. Worse, objects cannot generally be defined independently of one another (and in fact, as explained in the book, tend to produce code dependences that violate Parnas\u0026rsquo;s principles).\nDomain-driven design. DDD is a very popular and successful approach to software development, created by Eric Evans. It can be viewed as a modern incarnation of the idea of building a software system on an explicit model of its problem domain, which goes back to Simula and JSD. A key innovation of DDD is the idea of \u0026ldquo;bounded context\u0026rdquo;: that each system or app has its own domain model, which serves its own functionality, reflects the world view of its development team, and may differ from (and even be inconsistent with) the domain models of other systems that operate in the same (larger) domain. Concept design proposes a more fine-grained structure, focusing on modularity within an app, each concept in a sense having its own bounded context (defined by its state/data model). In addition to the domain modeling aspect, DDD embodies an extensive collection of patterns and practices for building more flexible software. One pattern in particular suggests you \u0026ldquo;look for the underlying conceptual contours\u0026rdquo;, and it seems likely that concept design should thus be a good match for DDD. Finally, one key difference: a domain-driven design typically starts by constructing a model of the specific domain in a bottom-up fashion; one popular approach called \u0026ldquo;event storming\u0026rdquo; starts by classifying key events in the domain (just as JSD did). Concept design instead starts with recognizing standard concepts that can be assembled for the app at hand, and thus places more emphasis on reuse of domain models. This difference should not be fundamental however, and it seems likely that the two approaches could be used profitably together.\nFeature-oriented development. Features are increments of functionality; a feature model comprises a set of features and constraints on which subsets of features can be combined together, implicitly defining a product family. Feature-based frameworks (such as Don Batory\u0026rsquo;s AHEAD tool suite) automate the configuring of features and merging of code fragments. In contrast to concepts, features are more flexible, and can not only model arbitrary increments of functionality but can also address aspects of a system that are not user-facing; a caching feature, for example, might improve performance without producing any observable change in behavior. The price paid is that features, unlike concepts, are not generally independent of one another, and cannot be easily reused across applications.\nCross-object modularity mechanisms. A variety of mechanisms have been developed to accommodate functionality that cross-cuts the traditional object boundaries in OO programming. These include aspect-oriented programming, subject-oriented programming and role-based programming. The latter two are similar to concepts in factoring out behaviors that serve distinct purposes, separating them from the existence of particular objects. Unlike concepts, however, these notions are not generally independent of one another, and (like features) are intended to be implemented in the context of a particular system and not transportable between systems.\nFeature interaction. In the context of telephony, \u0026ldquo;features\u0026rdquo; have a different connotation, and are (like concepts) user facing and typically intended to be independent of one another. The \u0026ldquo;feature interaction\u0026rdquo; problem arises when a system includes features that prescribe conflicting behaviors. In concept design terms, feature interaction is a violation of integrity, and would be resolved by not allowing conflicting features to be active at the same time. This is one approach taken in telephony, but more flexible approaches are taken too (for example, giving priority to one feature over another). This flexibility might be achieved with concepts by designing concepts with non-determinism that can be resolved in composition.\nMicroservices. Most backend applications are nowadays structured as a collection of \u0026ldquo;microservices\u0026rdquo;, each providing an API and its own internal logic and storage. A concept can be viewed, at least from a functionality perspective, as a \u0026ldquo;nanoservice\u0026rdquo;—like a microservice but with a much more limited scope (with a single focused purpose rather than a collection of purposes around some area of functionality such as billing or advertising). Microservices are not generally independent of one another, and because they aggregate app-specific collections of functions, are not reusable across apps.\nStrategies Each chapter of the book includes an outline at the end of some practical strategies, and a final chapter presents a set of questions for each kind of person (program manager, consultant, UX designer, etc) who might use concept design. Here are some highlights of ways to use concept design in your work:\nDesign concepts for a new app, or for new functionality in an existing app, using the concept design structure, formulating purposes and operational principles to bring design focus. Avoid reinventing the wheel when designing an app, by always looking for ways in which existing, familiar concepts might suffice (and by spotting concepts that are small variations away from familiar concepts). Inventory the concepts in your app (or app family) to get a bird\u0026rsquo;s eye view of its functionality. Construct a dependence diagram to show what subsets are possible. Do this as a retrospective review of an existing app, in designing a new app, or in planning extensions or digital transformations. Identify concepts that are the most valuable (eg, product differentiators), the most troublesome (in terms of user confusion/complaints, development costs, etc), the least valuable (which might be dropped or replaced by more powerful concepts), etc. Genericize one or more concepts by reformulating its purpose independently of the type of objects it works on, and consider how making it more polymorphic might allow it to be simplified and applied in more contexts within your app (and across your app family or suite). Decompose concepts that serve multiple purposes into single-purpose concepts that are synchronized together. Find familiar concepts lurking behind the concepts of your app, and adjust your concepts or decompose them to expose familiar concepts that will make the app more intelligible to users. Look for synchronization opportunities that would increase the degree of automation in your app; conversely look for ways in which synchronization is excessive and eliminates manual controls that users would welcome. Identify redundant concepts that could be removed by being replaced by existing concepts (which may need some enrichment). Identify overloaded concepts that are complex or brittle, and split them into separate concepts. When users have trouble understanding your app, first consider overloading as a possible cause. Examine the data model or schema of your app and consider how you might decompose it into the local data models of individual concepts. Create help and training materials that are concept-driven so they can be grasped more easily by users: follow the dependence diagram for ordering; use consistent names for a concept throughout; note when a familiar concept is being used; present concepts with purposes and operational principles first (before the details of all their actions). Fun things The end notes include mini-essays on some serious topics, including:\nEmpiricism and its pitfalls Design thinking and \u0026ldquo;content-free\u0026rdquo; process Verification and its pernicious consequences Christopher Alexander, patterns and misfits Inevitability as a design criterion Mental models and gulfs of evaluation and execution Normal and radical design The pitfalls of object-oriented programming and also include some lighter topics such as:\nMy favorite pasta sauce recipe How to prevent ice dams and water leaks in your house An Easter egg in Don Norman\u0026rsquo;s book Why pixels and inches in CSS don\u0026rsquo;t mean what you think Comments \u0026amp; reactions? Join the discussion at forum.softwareconcepts.io!\n","permalink":"https://essenceofsoftware.com/posts/distillation/","summary":"Save yourself the trouble of actually reading the book.","title":"The Essence of the Essence"},{"content":"Here is a lovely sketchnote by the wonderful artist and designer MJ Broadbent, which she created live during a keynote I gave about concept design at the SATURN conference in 2016. Concept design has come a long way since then, but many of the key ideas are here.\n","permalink":"https://essenceofsoftware.com/posts/sketchnote/","summary":"Early concept design ideas, drawn by MJ Broadbent.","title":"Concept Design Sketchnote"},{"content":"Yes, I know you get too much email too. But I wanted a chance to be in touch with people who are interested in concept design, so if you\u0026rsquo;d like to be included in my occasional mailings:\n","permalink":"https://essenceofsoftware.com/posts/subscribe/","summary":"Join an ultra-low-volume email list to hear new ideas about concepts and design.","title":"Design Updates in Your Mailbox"},{"content":"Concepts provide a framework for recording design experience. Designers often find themselves reinventing the wheel, designing and deploying concepts that have been built many times before, and then rediscovering a raft of subtle problems that were already known.\nMy dream is to have a concept catalog (or a collection of concept catalogs, perhaps organized by domains) that would hold a collection of concept definitions, and with each the accumulated experience and design wisdom from previous deployments of that concept.\nAs an example of what such a catalog entry might look like, here is a sample entry for the Upvote concept. Comments, suggestions and reactions welcome in the forum topic for this example.\nThis idea is inspired, of course, by the success of design patterns in programming.\nName: Upvote [Item, User]\nPurpose: Track relative popularity of items\nAlso known as: Like\nRelated concepts:\nReaction (send emotional reaction to author of post)\nRecommendation (track user approvals for future recommendations)\nModerate (maintain quality of forum by approving submissions)\nKarma (grant privileges to users based on good behavior)\nFlag (crowdsource moderation by having users mark bad items)\nState:\nupvotes, downvotes: Item -\u0026gt; set User count: Item -\u0026gt; one Int // item's count is defined as number of ups minus downs // all i: Item | i.count = #i.upvotes - #i.downvotes Actions:\nupvote (i: Item, u: User)\u2028u not in i.upvotes i.upvotes += u i.downvotes -= u downvote (i: Item, u: User)\u2028u not in i.downvotes i.downvotes += u i.upvotes -= u unvote (i: Item, u: User)\u2028u in i.(upvotes+downvotes) i.upvotes -= u i.downvotes -= u Operational principle:\nafter a sequence of upvote and downvote actions, the count of an item is equal to the number of users who upvoted minus the number who downvoted General notes\nSyntax. Since this is the first concept that I\u0026rsquo;m adding to the catalog, here are a few notes on the syntax I\u0026rsquo;m using. This is the structure I use in EOS, but with more formal definitions of the actions. I\u0026rsquo;m using Alloy-like syntax for expressions and statements, which is hopefully intuitive even to those unfamiliar with Alloy. The state and actions part of the concept model is not new to concept design; it\u0026rsquo;s just a definition of a state machine activated by atomic actions as you\u0026rsquo;d find in any formal modeling language (such as TLA+, B, Z, VDM, OCL).\nDeclarations. The declaration r: A -\u0026gt; B declares a relation from A to B, constrained by any multiplicities (using the keywords one for exactly one, lone for zero or one, some for one or more, and set for zero or more).\nAction definitions. Action definitions can include constraints on the pre-state, as well as update statements. For example, in upvote, the first line is a precondition saying that you can\u0026rsquo;t upvote an item if you\u0026rsquo;ve already upvoted it. An update statement changes a relation, using +/- for adding and removing tuples. For example, in upvote, the second line says that the set of users associated with the item i in the upvotes relation is increased by u (or, equivalently, the tuple i-\u0026gt;u is added to the relation).\nType parameters. The list of types after the name of the concept gives the type parameters. These are types that are polymorphic, and can be bound to other types when the concept is composed. In this case, all the types are parameters. The Item type, for example, may be bound to Comment or Post in another concept, and the User type may be bound to any kind of principal (as the term is used in the security community).\nOperational principle. The OP is given informally. As explained in EOS, it\u0026rsquo;s an archetypal scenario, and unlike use cases, doesn\u0026rsquo;t need to cover all the functionality (so note that unvote is not mentioned). In this case, it looks a bit pathological because the concept is pretty simple: it basically just counts votes.\nDesign issues\nNegative count. This design allows counts to go negative. An alternative is to make a minimum of zero (even if the number of downvotes is still tracked implicitly).\nUnvote as own action. In some deployments, you may use downvote to let a user reverse their upvote action instead of unvote, but this won\u0026rsquo;t work if downvoting is limited (eg, by Karma) to certain users (as in Hacker News).\nUsing count. The count of an item can be used in different ways. Often it is shown to users, and is used to determine the rank order in which items appear. Sometimes the count is used directly for item ordering (as in comments in the NY Times), but more complex schemes are common: in Hacker News, for example, the rank of a post is computed from the number of points, the post\u0026rsquo;s age, and other factors.\nPreventing double voting. This design prevents a user from voting twice on a single item. In practice, this requires either tracking the identity of the user (eg, with session tokens), or by using a proxy for the user, such as the IP address, MAC address or browser id.\nVisibility. Usually only the count relation (and not the upvotes and downvotes relations) is made visible, so users cannot see who voted for an item. For Facebook \u0026ldquo;likes\u0026rdquo;, usernames are visible, but that can be seen as an artifact of combining the Upvote concept with the Reaction concept.\nEventual consistency. Getting exact counts is generally not required, so common implementations scale by not requiring strong consistency. This means that a user who upvotes an item will generally see that item\u0026rsquo;s count increase, but may not see the effect of a simultaneous (or even earlier) upvote from another user until later.\nKnown uses. Universally used in all social media apps, typically for posts and comments. Facebook combines the Upvote, Reaction and Recommendation concepts into a single \u0026ldquo;Like\u0026rdquo; concept, with some confusing outcomes (for example, that an angry reactions counts as an upvote).\nSynchronizations. Commonly synchronized with authoring concepts (such as Comment and Post), and with Karma (where an upvote may be synchronized with a reward action, so that a user needs to obtain some number of upvotes before reaching a certain karma level).\n","permalink":"https://essenceofsoftware.com/posts/upvote/","summary":"An example of a concept catalog entry that defines a concept\u0026rsquo;s purpose, behavior and design issues.","title":"Upvote: An Example Concept"},{"content":"Coming soon!\n","permalink":"https://essenceofsoftware.com/drafts/intro/","summary":"Coming soon!","title":"Concepts: A Brief Intro"},{"content":"I\u0026rsquo;m excited to have been invited by the ACM Practitioner Board to give a tech talk at noon Eastern Time on Dec 1, 2021.\nUpdate: recording of the talk here\nThe Essence of Software (Or Why Systems Often Fail by Design, and How to Fix Them)\nWe’ve made great strides in software, but many systems are still hard to use or behave badly. Traditionally, we’ve looked to bugs in code to explain why systems go wrong—or to flaws in the user interface that may lead to misuse. In this talk, I’ll argue that the real problem often lies elsewhere: in the very concepts of the design. I’ll present a variety of surprising snags with familiar applications, from Dropbox to Gmail, and I’ll show how concepts can diagnose them and suggest fixes. I’ll explain in concrete and actionable terms what concepts are—essentially free-standing “nanoservices” that factor the behavior of a system into independent and reusable parts—and how you can apply them in your work, whether you’re a coder, program manager, software architect, UX designer, or consultant.\n","permalink":"https://essenceofsoftware.com/posts/acm-tech-talk/","summary":"Now updated with talk recording.","title":"ACM tech talk"},{"content":"You can download a free sample chapter from the book here.\n","permalink":"https://essenceofsoftware.com/posts/sample-chapter/","summary":"Download a free sample chapter.","title":"Sample book chapter"}]