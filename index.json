[{"content":"This article summarizes the key ideas in the book The Essence of Software. It is not intended to be understandable by itself. It gives almost no examples, makes claims without justifying them, and cites almost no related work. And, I\u0026rsquo;ll admit, it\u0026rsquo;s probably not that much fun to read. But, hey, at least it\u0026rsquo;s short(ish)!\nIf you\u0026rsquo;ve read the book, this summary may be a useful reminder of its ideas to help you solidify them in your mind; if you haven\u0026rsquo;t read it yet, it may give you a sense of what to expect (at least content-wise: the book is more fun, I hope!).\nThis summary assumes a fairly extensive background in software design and development. The book itself is aimed at a broader audience, introduces the ideas more gently by way of example, and relegates the harder technical stuff to end notes.\nDefining Software Design In most fields, \u0026ldquo;design\u0026rdquo; means shaping an artifact to meet the needs of users, thus sitting at the boundary between humans and machines. Despite Kapor\u0026rsquo;s notable manifesto in 1990, and the book edited by Winograd that followed in 1996, little attention has been paid to software design.\nEnormous effort, in contrast, has been devoted to software engineering (whose interest instead is software\u0026rsquo;s internal structure and means of construction). This disparity of attention has resulted in great advances in programming, represented by a major body of knowledge and well-known design principles.\nThe field of human-computer interaction has likewise produced an impressive body of knowledge about user interfaces and how they shape the way we understand and use software. But for software design, where the focus is on the fundamental abstractions that underlie both the interface and the implementation, our knowledge is much more limited, and we have had to be content with being guided instead by vaguer notions, and (albeit sensible) appeals to simplicity and clarity.\nThe Book\u0026rsquo;s Aims and Approach The aims of the book are to highlight a central aspect of software design; to lay out a way to structure and express software designs from this perspective; to provide some heuristics and principles for design; and, more generally, to inspire a renewed focus on software design as a discipline.\nThe book is driven by examples drawn from over 100 apps. By focusing on widely used software produced by the best companies, it seeks to show that serious problems are rife, and challenge even the most talented developers, and that the book\u0026rsquo;s ideas and techniques apply to real software.\nThe book presents a design approach comprising simple textual and diagrammatic notations, a collection of readily applicable heuristics, and some deeper principles. In order to explain the approach in more detail, and to show how it differs from many prior approaches, a collection of end notes is included covering topics from design thinking to formal methods.\nThe Problem Software is harder to use than it needs to be. We spend an increasing portion of our lives engaged with software apps and systems, so improving the design of software impacts the quality of our lives and our ease of working effectively together.\nAs software becomes an ever more critical part of our civic infrastructure, we rely on apps and systems to behave predictably and reliably. A high proportion of failures are due to user errors, for which poor design is usually to blame. And even when a failure is attributed to a bug in the code, it is likely that the bug is due to lack of clarity in design (rather than a simple failure to meet a specification).\nLack of clarity in software design also makes software harder to build, and leads to degradation over time as accretions to a codebase compromise its modularity yet further.\nLevels of Design Software design activities and criteria can be assigned to three levels: physical, which concerns the choice of colors, type, layout, etc, and is influenced by particular human anatomical and cognitive capabilities; linguistic, which concerns the use of icons and labels, terminology, etc, and is dependent on shared cultural and linguistic assumptions; and conceptual, which concerns the underlying semantics of the application, including the actions that can be performed and the effects they have, and the structure and interpretation of the state as viewed by the user.\nThe conceptual level is the most fundamental; different physical and linguistic designs for an app might be equally effective, but even small changes to the conceptual design are usually very disruptive to users. Users' problems with apps arise more often from incorrect conceptual understandings than from an inability to interpret the physical and linguistic signals of the user interface.\nThis is due in part to the great advances that have been made in the last decades at the physical and linguistic levels. Many books and online collections of heuristics teach user interface design very effectively, and given also that many client-side frameworks now provide professionally designed widgets, there is little excuse nowadays for a design that fails at these levels.\nPrior Work on Conceptual Design The importance of the conceptual level has been recognized for more than half a century. From early on, researchers noted the importance of a user\u0026rsquo;s \u0026ldquo;mental model\u0026rdquo;, and the need for the design to construct such a model explicitly, so that the user\u0026rsquo;s model and the system model coincide. Fred Brooks coined the term \u0026ldquo;conceptual integrity\u0026rdquo; and argued that the conceptual aspects of software design represented the essence of the field, as opposed to the accidental aspects, to which he relegated the concerns of \u0026ldquo;representation.\u0026rdquo; The fields of conceptual modeling, domain modeling and formal methods all emphasized the centrality of an abstract model of state (and, in the case of formal methods, also behavior) in the design of software.\nAnd yet none of these fields expressly addressed the problem of designing the conceptual structure of software in order to meet the needs of the user and to align the user\u0026rsquo;s understanding. Formal methods focused primarily on the problem of correctness, and ensuring conformance of the implementation to the model. Conceptual modeling and domain modeling focused primarily on the representation of knowledge about the context of operation of a system, rather than on the structures that the designer invented.\nMost curiously missing was a well defined notion of \u0026ldquo;concept.\u0026rdquo; Even in the field of conceptual modeling, there is no shared understanding of what a concept might be, or even well-known candidate definitions. An entire conceptual model seems to be too large to count as a single concept, and its constituent entities (or classes or objects) are too small, especially since an informal understanding of a concept tends to involve relationships amongst multiple elements.\nA New Definition of Concept A concept is a reusable unit of user-facing functionality that serves a well-defined and intelligible purpose. Each concept maintains its own state, and interacts with the user (and with other concepts) through atomic actions. Some actions are performed by users; others are output actions that occur spontaneously under the control of the concept.\nA concept typically involves objects of several different kinds, holding relationships between them in its state. For example, the Upvote concept, whose purpose is to rank items by popularity, maintains a relationship between the items and the users who have approved or disapproved of them. The state of a concept must be sufficiently rich to support the concept\u0026rsquo;s behavior; if Upvote lacked information about users, for example, it would not be able to prevent double voting. But the concept state should be no richer than it need be: Upvote would not include anything about a user beyond the user\u0026rsquo;s identity, since the user\u0026rsquo;s name (for example) plays no role in the concept\u0026rsquo;s behavior.\nConcept Reuse and Familiarity Most concepts are reusable across applications; thus the same Upvote concept appears for upvoting comments in the New York Times and for upvoting answers on Stack Overflow. A concept can also be instantiated multiple times within the same application.\nThis archetypal nature of concepts is essential. From the user\u0026rsquo;s perspective, it gives the familiarity that makes concepts easy to understand: a user encountering the same context in a new setting brings their understanding of that concept from their experience in previous settings.\nFrom a designer\u0026rsquo;s perspective, it allows concepts to be repositories of design knowledge and experience. When a developer implements Upvote, even if they can\u0026rsquo;t reuse the code of a prior implementation, they can rely on all the discoveries and refinements previously made. Many of these are apparent in the behavior of the concept itself, but others are associated with the implementation, or are subtle enough to need explicit description. The community of designers could develop \u0026ldquo;concept catalogs\u0026rdquo; that capture all this knowledge, along with relationships between concepts (for example, that Upvote often relies on the Session concept for identifying users, which itself is associated with the User concept for authenticating users).\nConcept Independence Perhaps the most significant distinguishing feature of concepts, in comparison to other modularity schemes, is their mutual independence. Each concept is defined without reference to any other concepts, and can be understood in isolation.\nEarly work on mental models established the principle that, in a robust model, the different elements must be independently understandable. The same holds in software: the reason a user can make sense of a new social media app, for example, is that each of the concepts (Post, Comment, Upvote, Friend, etc) are not only familiar but also separable, so that understanding one doesn\u0026rsquo;t require understanding another.\nConcept independence lets design scale, because individual concepts can be worked on by different designers or design teams, and brought together later. Reuse requires independence too, because coupling between concepts would prevent a concept from being adopted without also including the concepts it depends on.\nPolymorphism is key to independence: the designer of a concept should strive to make the concept as free as possible of any assumptions about the content and interpretation of objects passed as action arguments. Even if a Comment concept is used within an app only for comments on posts, it should be described as applying comments to arbitrary targets, defined only by their identity.\nPushing polymorphism as far as possible is a useful strategy: for getting to the essence of a concept; for finding other opportunities to use a concept within the same app (and in other apps); for discovering that what appears to be an app-specific concept is actually a general and familiar one; and, when it\u0026rsquo;s not possible, for identifying concept subtleties or design flaws.\nConcepts can be implemented independently also; in the Deja Vu platform, Santiago Perez De Rosso showed how apps could be constructed by glueing together reusable, full-stack concepts drawn from a library.\nA Structure for Describing Concepts To work with concepts, we need a simple structure for describing them. A concept is defined by its behavior, which comprises its state space and a set of actions. These can be defined using standard methods and notations.\nFor defining the state space, a data model is given that consists of a collection of components, each of which is a scalar/option, set or relation (of any arity). This model can be recorded with textual declarations or as an extended entity-relationship diagram. The details of the data model are not fundamental to concepts, and different models could be used. What is important is that the state of a concept is (by default) visible to users, so states should make sense to users (and at the very least should be defined explicitly in the spirit of \u0026ldquo;model-based specification\u0026rdquo; rather than implicitly by algebraic axioms).\nActions can be initiated by the user or by the system, and a single action can have both inputs and outputs. A single action can abstract what would be an entire use case in object-oriented modeling approaches, allowing a much terser form of description. An action can also abstract away (that is, not represent in detail) the creation of complex inputs; for example, an action input may be a rich-text object that in the implementation would be produced by an extended interaction with a rich-text editor.\nActions read and write states. An action may have a precondition that makes it applicable only in certain states; when the precondition does not hold, the action is blocked and may not occur. Actions can be non-deterministic, resulting in more than one possible outcome for a given pre-state/input combination. But any non-determinism must be exposed in output arguments, so that the state of a concept is always a function of the trace of actions that have occurred so far. For example, an airline reservation concept could have an assignSeat action that picks an arbitrary seat and assigns it to the customer, but the seat must be represented as an output of the action (in addition to appearing in the post-state of the relation that maps customers to seats).\nFrom a data modeling perspective, there is no global data model. Instead, there is a collection of local data models, one for each concept. Each concept\u0026rsquo;s data model is just rich enough to support its actions. (In teaching data modeling, I have found that this makes it much easier for programmers to scope their models. In traditional modeling, it\u0026rsquo;s all too easy to get carried away with building a data model based on ontological observations that are not actually relevant to the design of the system.)\nIf the state and action definitions are written in a formal notation such as Alloy, the concept behavior can be analyzed automatically, with generation of sample executions, comparison of action versions, and checking properties. The modularity that concepts provide amplify the effectiveness of automated analysis. Such analysis is always inherently intractable (the number of executions to check rising super-exponentially with the number of objects in the state), so researchers have always looked for ways to decompose a system into smaller parts. Concepts provide such a decomposition, aligned naturally with the functionality boundaries of the system.\nThe definition of a concept augments this basic behavioral description with two more novel parts explained in more detail below: the purpose and the operational principle.\nConcept Purposes The idea that an artifact should have a purpose distinct from its specification is hardly novel, and many researchers have recognized the importance of purposes, and the impossibility of expressing them fully and precisely (most notably Christopher Alexander in Notes on the Synthesis of Form).\nWhat is novel in concept design is the idea that it is not sufficient for the system or app as a whole to have a purpose (or a collection of purposes). Each concept in its design should have its own purpose. A concept\u0026rsquo;s purpose defines, in a general setting, the reason for its invention and what benefits it offers; in the setting of a particular app, it defines the motivation and justification for including the concept.\nPurposes also clarify subtle distinctions between related concepts. In social media, for example, there are several concepts that may sit behind a \u0026ldquo;thumbs up\u0026rdquo; widget: Upvote, whose purpose is to rank items by popularity so that users (purportedly) see the most valuable content first; Reaction, whose purpose is to convey an emotional reaction to the author of an item; Recommendation, whose purpose is to learn a user\u0026rsquo;s preferences so that subsequent items can be recommended more reliably; and Profile, whose purpose is to track the user\u0026rsquo;s interests in order to target advertising.\nBecause purposes sit at the boundary of the human/computer interface, they cannot be judged formally (the way correctness can, eg). Nevertheless, the book provides criteria for determining whether a purpose is compelling, and when two distinct purposes may be masquerading as one.\nThe Operational Principle A concept definition also includes its operational principle (OP), an archetypal scenario that shows how the concept fulfills its purpose.\nSuperficially, the OP is like a use case, but it plays a very different role. Use cases are a specification notation, and a full spec typically requires many use cases. Use cases are often expressed at a low level too, in terms of the micro-interactions of the user interface (clicking buttons etc). Since a concept\u0026rsquo;s actions fully define its behavior, nothing more is needed to predict how the concept will behave.\nInstead, the OP captures the dynamic essence of the concept, telling the most basic story about how the concept works. Sometimes the OP is so simple it barely even needs stating: when you add a comment to a post, your comment will subsequently appear along with the post (the OP of the Comment concept). But often the OP is more interesting. It may require two distinct scenarios: when you delete a item, you can restore it from the trash; once you empty the trash, though, it\u0026rsquo;s gone forever and its space is reclaimed (Trash). It may need to be quite elaborate in order to demonstrate the purpose and distinguish the concept from similar but less powerful concepts: if you assign a style to two items, and then you update the style, both items will be updated in concert (Style). And it may involve multiple users: after users have upvoted items, the items will be ranked by the number of times they were upvoted (Upvote).\nThe OP may also be aspirational, applying only in ideal circumstances (even if they are typical). It is not true that if you reserve a restaurant table, and then turn up, a table will necessarily be available (since guests at your table may have stayed longer than expected); nor that a successful authentication associated with a user account must have been performed by the same user that registered the account (since someone may have stolen your password). Like many aspects of concepts, the OP may appear to be obvious until you consider things more deeply.\nThe OP often provides the clearest way to explain a concept. To use the PORT elevator system, a rider selects their destination floor on the device in the lobby, which responds with the identifier of the lift car to be taken; the rider enters that car and is taken to their floor. This is complicated enough—and different enough from standard elevators—for the maker (Schindler) to advertise that it\u0026rsquo;s \u0026ldquo;as easy as 1-2-3\u0026rdquo; (namely involves an OP with multiple steps).\nParadoxically a full behavioral description is often less helpful, since (a) it fails to distinguish the essential aspects of the concept design (how style updates effect items) from more arbitrary design decisions (what happens when a style is deleted); and (b) it conveys the motivation for the behavior. For Michael Polanyi, from whose work the idea of the OP is taken, this latter consideration is the key to understanding the difference between design/engineering on the one hand and science on the other (put bluntly, why physics cannot explain how a clock works).\nConcept Synchronization Within an app, concepts can operate largely without interaction: commenting on posts, for example, may be orthogonal to upvoting them. But often concepts need to be coupled together to achieve the app\u0026rsquo;s goals. For example, it may be problematic for users to edit posts after they have been upvoted (since the upvotes responded to content that may have changed). To mitigate this the upvote action of the Upvote concept could be synchronized with the edit action of the Post concept, to prevent edits after a post has been upvoted or to remove upvotes when a post is edited.\nFor some concepts, synchronization is part of their intended usage. An access control concept is intended to suppress some actions in another concept when the user lacks the right permissions; a subscription concept is intended to react to certain actions by generating subsequent notification actions. In these cases, the concept typically offers \u0026lsquo;placeholder\u0026rsquo; actions that are synchronized with the real actions in other concepts: an access control concept may have an access action, for example, which is then pinned to the action to be controlled in another concept.\nSynchronizations are defined reactively: when an action occurs in one concept, some actions should occur in other concepts. Arguments can be passed between actions, so that synchronization includes data flow. Each synchronization is atomic and happens in its entirety or not at all, so if one of the reactive actions is blocked by its concept, the initial action cannot occur either.\nThis model of communication and interaction is inspired by Hoare\u0026rsquo;s CSP, and can be formalized in its terms. A crucial property of the model is that the behavior of each individual concept is preserved. Synchronization can prevent a concept from executing an action, and it can limit the arguments presented to an action, but it can never cause an action to occur (or an output to be produced) that would not be possible for the concept in isolation. As will be explained below, composing concepts maintains their integrity.\nThe synchronization mechanism is also essential for maintaining concept independence and avoiding the need for one concept to \u0026lsquo;call\u0026rsquo; another. At the code level, composition requires mediators to implement the synchronization; these mediators make reference to the concepts, but the concepts themselves remain free of mutual references.\nSynchronization and Automation Synchronization of concepts is often a form of automation, in which the user is saved the trouble of executing a concept action because it follows execution of an action in another concept automatically. Omission of a desirable automation can be attributed to under-synchronization of an app\u0026rsquo;s concepts: in Zoom, for example, the raised hand concept might be synchronized with the audio muting concept so that participants' hands are automatically lowered after they have their turn.\nAutomation preempts the user\u0026rsquo;s manual control and thus, if not configurable, can be problematic. Such automation can be attributed to over-synchronization of an app\u0026rsquo;s concepts: in some calendar apps, deleting in the event concept leads undesirably to declining in the invitation concept.\nSynchronization and Decomposition What an app presents as a single concept may be better understood as a synchronization of multiple component concepts. A hint that such a decomposition is warranted is often found in the presented concept having multiple, conflicting purposes.\nFacebook, for example, appears to offer a \u0026lsquo;like\u0026rsquo; concept, but on closer examination, this concept is a synchronization of several of the concepts described above: Upvote, Recommendation, Reaction and Profile. This synchronization is responsible for some confusions and critical commentary about Facebook\u0026rsquo;s design (notably, that an \u0026lsquo;angry\u0026rsquo; reaction produces a positive upvote—by some accounts counted for more than a simple \u0026lsquo;like\u0026rsquo;). With this decomposition in mind, different design options are easy to see: having separate buttons for \u0026ldquo;I\u0026rsquo;m angry\u0026rdquo; and \u0026ldquo;I want to see more of this kind of post\u0026rdquo;, for example.\nConcept Synergy In most compositions, concepts bring additive value. But in some designs, concepts can take advantage of each other so that one concept achieves its own functionality in part by relying on another concept. This is synergy in the setting of concept design, where the value of putting two concepts together is more than the sum of their individual values.\nAn example is Apple\u0026rsquo;s synergistic composition of the Folder and Trash concepts. By making the trash a folder, the design allows the action of moving items between folders to be used to restore items from the trash. Achieving this synergy is non-trivial, and the book explains its subtle evolution over time.\nAttempted synergies can backfire. A version of Outlook placed system logs (reporting for example on connection failures between client and server) in mail folders as if they were messages, but this led to numerous problems (for example that reports of connection failure could not be delivered to clients if\u0026hellip; connections failed).\nConcept Dependence Diagrams As explained above, concepts are inherently uncoupled and free standing, so they can be understood, designed, evaluated and reused independently. Bringing concepts together in an app does not couple them either, since the synchronization mechanism ensures that each concept will conform to its own behavioral expectations even if its actions are tied to the actions of other concepts. Furthermore, implementation need not introduce any dependencies between concepts.\nThere is a kind of dependence between concepts, however, that is useful to analyze, and that arises in the context of usage in a particular app or system. A concept C1 is said to depend on a concept C2 in an app A when the inclusion of C1 only makes sense if C2 is also present. Note that \u0026ldquo;makes sense\u0026rdquo; doesn\u0026rsquo;t mean that C1 would somehow break if C2 were missing, so there is no traditional software-engineering dependence here. Rather, the dependence reflects an understanding of the role of C1 in A. In a social media app with a Comment concept and a Post concept, for example, Comment might depend on Post because it was included to allow users to comment on posts, and if there are no posts, there\u0026rsquo;s not much point in having comments.\nAs with conventional dependencies, the concept dependence relation can be depicted as a dependence graph or diagram. Dependences have several uses. They determine which orders of explanation of an app\u0026rsquo;s concepts will be intelligible; you\u0026rsquo;d explain posts before comments on posts, for example, They define, implicitly, an entire application family (as the set of subgraphs in which some subset of the concepts appears and a concept never appears without those it depends on). The dependence diagram can thus be used to make scoping decisions about which concepts to include or exclude. Dependencies also suggest a development order: it\u0026rsquo;s better to build Post before Comment, so that comments have targets to be tested on.\nConcept Mapping In an implementation of a concept design, the concepts must be mapped to the user interface, connecting the conceptual level of design to the physical and linguistic levels. Actions might be executed by gestures or button presses, for example, and the states of the concepts will be displayed in various views.\nThe standard techniques and heuristics of user interface design apply directly to concept mapping. The lens of concept design helps focus this work.\nSome concepts present tricky mapping challenges, and good mappings can be part of the design knowledge associated with a concept. For the filtering view in the Label concept, in which a collection of items is filtered by a selected label, for example, it might seem desirable to maintain an invariant that the items displayed are exactly those carrying the label, but this turns out not to be a good idea.\nIn Gmail, the Label concept is used to classify messages, but the user interface shows messages in the context of conversations and associates labels with conversations instead. This mapping design is troubled, and leads to a variety of odd behaviors.\nTesting and Prototyping Are Not Enough A concept design is ultimately evaluated in the context of use, and misfits (in which a design fails to fulfill its intended purpose) are never fully predictable, because they depend on properties of the human environment which may not even be knowable until the design is deployed.\nUser testing offers some limited value, especially for evaluating concept mappings, and for catching egregious flaws, but (unlike real deployment) will rarely encounter the corner cases that are most troublesome in a design. Prototyping is a valuable strategy for exploring candidate designs early on, and indeed many of the practices of design thinking can be fruitfully combined with concept design, and are made more useful by the separation of concerns that concepts offer.\nBut generate-and-test is not a viable method for finding a good design in a large design space, let alone a great design. To do that requires an expert designer who can apply prior knowledge of likely problems and known solutions, often acquired in very different settings. Concepts provide a framework for recording and retrieving such knowledge.\nA note for computer scientists: the known problems of standard concepts are sometimes grounded in technology (eg, the difficulty of achieving consistent views of data in a distributed system) but are more often a result of human behavior (eg, that ticket sales invite scalpers who then drive up prices).\nThe Need for Concept Design Principles Over the last few decades, a rich body of UX design principles has been developed. These include prescriptive adaptations of psychological ideas, such as the Gestalt principles of grouping, which can be used to guide layout design, and James Gibson\u0026rsquo;s notion of affordance, made applicable in user interfaces by Don Norman\u0026rsquo;s principle that affordances should be explicitly \u0026ldquo;signified\u0026rdquo;. Norman\u0026rsquo;s book The Design of Everyday Things introduced several additional principles, such as the idea of \u0026ldquo;mapping\u0026rdquo; (a different usage from concept mapping) in which a user interface mirrors the structure of the domain being controlled. Other pioneers produced explicit collections of principles: Ben Shneiderman\u0026rsquo;s golden rules, Jakob Nielsen\u0026rsquo;s heuristics, and Bruce Tognazzini\u0026rsquo;s principles of interaction design.\nEspecially in the hands of experts, these principles make it possible to design a user interface that is likely to be highly usable, with a low probability of serious usability flaws. Indeed, there is no excuse nowadays for poor user interface design, and user testing is much less important for routine design work (although it\u0026rsquo;s still valuable of course, especially for very novel or critical designs).\nAlmost all of these principles, however, are focused on the physical and linguistic levels of design. New principles are needed at the conceptual level. The book presents three such principles and explains them in detail with many examples from contemporary apps.\nConcept Design Principles Familiarity. When possible, a familiar concept should be preferred to a new, unfamiliar one. With familiar concepts, users can rely on their prior experience, and don\u0026rsquo;t need to learn a concept afresh. And designers can take advantage of the body of knowledge associated with a known concept, reducing the risk of a design with unexpected misfits. The familiarity principle can be seen as an application of a meta principle of consistency: when a purpose arises in an app that has arisen before, the same solution should be used.\nSpecificity. If you draw up a list of the purposes purportedly served by an app, the purposes and the concepts that aim to fulfill them should be in one-to-one correspondence. This implies first that every purpose should have at least one concept that fulfills it, and that every concept has some purpose that motivates it. So much is obvious, although there are examples in real apps (which the book explains) of unhelpful concepts that serve no user purpose, and purposes that are essential to an app that are fulfilled by no concept.\nThe more subtle implications are: no redundancy, namely that each purpose should be fulfilled by at most one concept, and no overloading, namely that each concept should serve at most one purpose. Redundancy is clearly undesirable because it involves a waste of resources (in the designer\u0026rsquo;s work and in the user\u0026rsquo;s understanding). Overloading is a more subtle notion: that a concept that tries to serve multiple purposes is pulled in different directions, and cannot serve any one purpose effectively. This idea is related to the independence axiom in Nam Suh\u0026rsquo;s theory of mechanical design, and to the common observation in programming that each segment of code should have a single goal.\nThe book gives many examples of concepts doomed by overloading, classifying them into different causes for the overloading:\n false convergence, when a concept is designed for two different functions that were assumed (wrongly) to be aspects of the same purpose; denied purpose, when a purpose was ignored by the designer, despite the desires of users; emergent purposes, in which new purposes arise for old concepts, often invented by the users themselves; and piggybacking, when an existing concept is adapted or extended to accommodate a new purpose.  Integrity. This principle says that when concepts are put together into an app, the each concept should continue to behave according to its (app-independent) concept definition. If concepts are composed by synchronization, integrity will be preserved by design. But if composition is more ad hoc, or if concepts are adjusted to suit the larger context of the app, there is a risk of violation. Google Drive, for example, offers a sync concept (not to be confused with concept sync!) in which local files on disk are kept in sync with files in the cloud. But in an egregious violation of integrity of this concept, only conventional files are properly synced, and files associated with Google Apps (such as Google Docs) are treated specially, and are represented on the local disk not by their contents but by a URL. A lack of awareness of this limitation has been catastrophic for some users.\nComparisons to Other Approaches Concept design builds on more than 50 years of advances in a variety of fields, and contributes some new ideas. First, some work that sounds similar but is not really relevant:\n  Concept maps are diagrammatic representations of collections of facts, with each edge representing a proposition that applies a predicate (the label of the edge) to two atoms (the nodes it connects). Concept maps are an application of knowledge graphs; they were proposed as an educational tool. They are \u0026ldquo;conceptual\u0026rdquo; in the sense that predicate logic lets you formalize all kinds of relationships, at any level of abstraction; and since the predicates don\u0026rsquo;t need to be designated (using Michael Jackson\u0026rsquo;s term), they can express ideas that would be hard to nail down precisely. The very flexibility of concept maps seems to limit their leverage in software design.\n  Concept lattices are representations of partial orders between classifications, where the order is set inclusion. Classification is a useful activity but is limited in the context of software design because it doesn\u0026rsquo;t address relationships, and is usually static, so does not address behavior.\n  At the other end of the spectrum, the most closely related work is:\n  Conceptual modeling. The field of conceptual modeling is broad and has many motivations, but part of it is concerned with explicit representations of the structures that underlie both applications and the mental models of users. The emphasis of the field has tended in the direction of ontologies (eg, for reasoning and knowledge representation), or in the direction of domain modeling (eg, for understanding the environment in which a software system operates), and in these respects conceptual structures are usually discovered rather than invented. In contrast, concept design focuses more on concepts as socio-technical inventions that serve a purpose. Most conceptual models are essentially abstract data models (in the spirit of entity-relationship diagrams), although there is work on dynamic models too (although these are hard to distinguish from standard kinds of dynamic models such as Statecharts). What concept design seeks to provide, which seems to be missing from conceptual modeling, is the notion of a identifiable concepts. Without this, there can be no modularity in conceptual models, and it is not possible to talk about concepts as separable contributions, to identify common concepts between models, or to reuse concepts. The terminology of conceptual modeling sometimes seems to imply that the entities of a data model are concepts, but these are not good concepts, since concepts typically involve relationships between objects. Some approaches seek to identify concepts with objects or classes, but this has an implementation flavor to it, since there is rarely a natural way to assign relationships and behavior to a single object or class.\n  Objects and classes. In the early days of object-oriented programming and development, the idea that objects naturally mirrored or modeled the real world was seen as a major benefit. Over time, the idea became less plausible, first because object-oriented programming took on more arcane forms moving further away from domain structures (under the influence of the Gang of Four patterns and other advanced programming techniques), and second because the inherent implementation bias in object-oriented design became clearer. The key problem is that, in the real world, the properties and behavior of objects involve relationships between them, and can rarely be satisfactorily assigned to individual objects. In practice, this is usually addressed by defining objects that hold relationships between other objects, but such a style is not really object-oriented. Worse, objects cannot generally be defined independently of one another (and in fact, as explained in the book, tend to produce code dependences that violate Parnas\u0026rsquo;s principles).\n  Domain-driven design. DDD is a modern incarnation of the important idea of building a software system on an explicit model of its problem domain, which goes back to Simula and JSD. A key innovation of DDD is the idea of \u0026ldquo;bounded context\u0026rdquo;: that each system or app has its own domain model, which serves its own functionality, reflects the world view of its development team, and may differ (or even be inconsistent with) the domain models of other systems that operate in the same (larger) domain. Concept design offers a more fine-grained structure, giving modularity within an app, and goes beyond the notion of bounded context with each concept having its own local data model. The need for this kind of modularity is mentioned in many of the DDD patterns (one pattern, eg, suggests you \u0026ldquo;look for the underlying conceptual contours\u0026rdquo;). Concept design shows how to do this, and should thus complement DDD well. Most importantly, concept design effectively separates the application-specific and general parts of a domain model, so that the entire domain model does not need to be built from scratch, and structures and knowledge associated with them can be reused.\n  Feature-oriented development. Features are increments of functionality; a feature model comprises a set of features and constraints on which subsets of features can be combined together, implicitly defining a product family. Feature-based frameworks (such as Don Batory\u0026rsquo;s AHEAD tool suite) automate the configuring of features and merging of code fragments. In contrast to concepts, features are more flexible, and can not only model arbitrary increments of functionality but can also address aspects of a system that are not user-facing; a caching feature, for example, might improve performance without producing any observable change in behavior. The price paid is that features, unlike concepts, are not generally independent of one another, and cannot be easily reused across applications.\n  Cross-object modularity mechanisms. A variety of mechanisms have been developed to accommodate functionality that cross-cuts the traditional object boundaries in OO programming. These include aspect-oriented programming, subject-oriented programming and role-based programming. The latter two are similar to concepts in factoring out behaviors that serve distinct purposes, separating them from the existence of particular objects. Unlike concepts, however, these notions are not generally independent of one another, and (like features) are intended to be implemented in the context of a particular system and not transportable between systems.\n  Feature interaction. In the context of telephony, \u0026ldquo;features\u0026rdquo; have a different connotation, and are (like concepts) user facing and typically intended to be independent of one another. The \u0026ldquo;feature interaction\u0026rdquo; problem arises when a system includes features that prescribe conflicting behaviors. In concept design terms, feature interaction is a violation of integrity, and would be resolved by not allowing conflicting features to be active at the same time. This is one approach taken in telephony, but more flexible approaches are taken too (for example, giving priority to one feature over another). This flexibility might be achieved with concepts by designing concepts with non-determinism that can be resolved in composition.\n  Microservices. Most backend applications are nowadays structured as a collection of \u0026ldquo;microservices\u0026rdquo;, each providing an API and its own internal logic and storage. A concept can be viewed, at least from a functionality perspective, as a \u0026ldquo;nanoservice\u0026rdquo;—like a microservice but with a much more limited scope (with a single focused purpose rather than a collection of purposes around some area of functionality such as billing or advertising). Microservices are not generally independent of one another, and because they aggregate app-specific collections of functions, are not reusable across apps.\n  Strategies Each chapter of the book includes an outline at the end of some practical strategies, and a final chapter presents a set of questions for each kind of person (program manager, consultant, UX designer, etc) who might use concept design. Here are some highlights of ways to use concept design in your work:\n Design concepts for a new app, or for new functionality in an existing app, using the concept design structure, formulating purposes and operational principles to bring design focus. Avoid reinventing the wheel when designing an app, by always looking for ways in which existing, familiar concepts might suffice (and by spotting concepts that are small variations away from familiar concepts). Inventory the concepts in your app (or app family) to get a bird\u0026rsquo;s eye view of its functionality. Construct a dependence diagram to show what subsets are possible. Do this as a retrospective review of an existing app, in designing a new app, or in planning extensions or digital transformations. Identify concepts that are the most valuable (eg, product differentiators), the most troublesome (in terms of user confusion/complaints, development costs, etc), the least valuable (which might be dropped or replaced by more powerful concepts), etc. Genericize one or more concepts by reformulating its purpose independently of the type of objects it works on, and consider how making it more polymorphic might allow it to be simplified and applied in more contexts within your app (and across your app family or suite). Decompose concepts that serve multiple purposes into single-purpose concepts that are synchronized together. Find familiar concepts lurking behind the concepts of your app, and adjust your concepts or decompose them to expose familiar concepts that will make the app more intelligible to users. Look for synchronization opportunities that would increase the degree of automation in your app; conversely look for ways in which synchronization is excessive and eliminates manual controls that users would welcome. Identify redundant concepts that could be removed by being replaced by existing concepts (which may need some enrichment). Identify overloaded concepts that are complex or brittle, and split them into separate concepts. When users have trouble understanding your app, first consider overloading as a possible cause. Examine the data model or schema of your app and consider how you might decompose it into the local data models of individual concepts. Create help and training materials that are concept-driven so they can be grasped more easily by users: follow the dependence diagram for ordering; use consistent names for a concept throughout; note when a familiar concept is being used; present concepts with purposes and operational principles first (before the details of all their actions).  Fun things The end notes include mini-essays on some serious topics, including:\n Empiricism and its pitfalls Design thinking and \u0026ldquo;content-free\u0026rdquo; process Verification and its pernicious consequences Christopher Alexander, patterns and misfits Inevitability as a design criterion Mental models and gulfs of evaluation and execution Normal and radical design The pitfalls of object-oriented programming  and also include some lighter topics such as:\n My favorite pasta sauce recipe How to prevent ice dams and water leaks in your house An Easter egg in Don Norman\u0026rsquo;s book Why pixels and inches in CSS don\u0026rsquo;t mean what you think  Comments \u0026amp; reactions? Join the discussion at forum.softwareconcepts.io!\n","permalink":"https://essenceofsoftware.com/posts/distillation/","summary":"Save yourself the trouble of actually reading the book.","title":"The Essence of the Essence"},{"content":"Here is a lovely sketchnote by the wonderful artist and designer MJ Broadbent, which she created live during a keynote I gave about concept design at the SATURN conference in 2016. Concept design has come a long way since then, but many of the key ideas are here.\n  ","permalink":"https://essenceofsoftware.com/posts/sketchnote/","summary":"Some concept design ideas in a graphical poster, thanks to MJ Broadbent.","title":"Concept Design Sketchnote"},{"content":"Yes, I know you get too much email too. But I wanted a chance to be in touch with people who are interested in concept design, so if you\u0026rsquo;d like to be included in my occasional mailings:\n\n","permalink":"https://essenceofsoftware.com/posts/subscribe/","summary":"Join an ultra-low-volume email list to hear new ideas about concepts and design.","title":"For updates on design..."},{"content":"Concepts provide a framework for recording design experience. Designers often find themselves reinventing the wheel, designing and deploying concepts that have been built many times before, and then rediscovering a raft of subtle problems that were already known.\nMy dream is to have a concept catalog (or a collection of concept catalogs, perhaps organized by domains) that would hold a collection of concept definitions, and with each the accumulated experience and design wisdom from previous deployments of that concept.\nAs an example of what such a catalog entry might look like, here is a sample entry for the Upvote concept. Comments, suggestions and reactions welcome in the forum topic for this example.\nThis idea is inspired, of course, by the success of design patterns in programming.\nName: Upvote [Item, User]\nPurpose: Track relative popularity of items\nAlso known as: Like\nRelated concepts:\nReaction (send emotional reaction to author of post)\nRecommendation (track user approvals for future recommendations)\nModerate (maintain quality of forum by approving submissions)\nKarma (grant privileges to users based on good behavior)\nFlag (crowdsource moderation by having users mark bad items)\nState:\nupvotes, downvotes: Item -\u0026gt; set User count: Item -\u0026gt; one Int // item's count is defined as number of ups minus downs // all i: Item | i.count = #i.upvotes - #i.downvotes Actions:\n\u2028upvote (i: Item, u: User)\u2028u not in i.upvotes i.upvotes += u i.downvotes -= u downvote (i: Item, u: User)\u2028u not in i.downvotes i.downvotes += u i.upvotes -= u unvote (i: Item, u: User)\u2028u in i.(upvotes+downvotes) i.upvotes -= u i.downvotes -= u Operational principle:\nafter a sequence of upvote and downvote actions, the count of an item is equal to the number of users who upvoted minus the number who downvoted General notes\nSyntax. Since this is the first concept that I\u0026rsquo;m adding to the catalog, here are a few notes on the syntax I\u0026rsquo;m using. This is the structure I use in EOS, but with more formal definitions of the actions. I\u0026rsquo;m using Alloy-like syntax for expressions and statements, which is hopefully intuitive even to those unfamiliar with Alloy. The state and actions part of the concept model is not new to concept design; it\u0026rsquo;s just a definition of a state machine activated by atomic actions as you\u0026rsquo;d find in any formal modeling language (such as TLA+, B, Z, VDM, OCL).\nDeclarations. The declaration r: A -\u0026gt; B declares a relation from A to B, constrained by any multiplicities (using the keywords one for exactly one, lone for zero or one, some for one or more, and set for zero or more).\nAction definitions. Action definitions can include constraints on the pre-state, as well as update statements. For example, in upvote, the first line is a precondition saying that you can\u0026rsquo;t upvote an item if you\u0026rsquo;ve already upvoted it. An update statement changes a relation, using +/- for adding and removing tuples. For example, in upvote, the second line says that the set of users associated with the item i in the upvotes relation is increased by u (or, equivalently, the tuple i-\u0026gt;u is added to the relation).\nType parameters. The list of types after the name of the concept gives the type parameters. These are types that are polymorphic, and can be bound to other types when the concept is composed. In this case, all the types are parameters. The Item type, for example, may be bound to Comment or Post in another concept, and the User type may be bound to any kind of principal (as the term is used in the security community).\nOperational principle. The OP is given informally. As explained in EOS, it\u0026rsquo;s an archetypal scenario, and unlike use cases, doesn\u0026rsquo;t need to cover all the functionality (so note that unvote is not mentioned). In this case, it looks a bit pathological because the concept is pretty simple: it basically just counts votes.\nDesign issues\nNegative count. This design allows counts to go negative. An alternative is to make a minimum of zero (even if the number of downvotes is still tracked implicitly).\nUnvote as own action. In some deployments, you may use downvote to let a user reverse their upvote action instead of unvote, but this won\u0026rsquo;t work if downvoting is limited (eg, by Karma) to certain users (as in Hacker News).\nUsing count. The count of an item can be used in different ways. Often it is shown to users, and is used to determine the rank order in which items appear. Sometimes the count is used directly for item ordering (as in comments in the NY Times), but more complex schemes are common: in Hacker News, for example, the rank of a post is computed from the number of points, the post\u0026rsquo;s age, and other factors.\nPreventing double voting. This design prevents a user from voting twice on a single item. In practice, this requires either tracking the identity of the user (eg, with session tokens), or by using a proxy for the user, such as the IP address, MAC address or browser id.\nVisibility. Usually only the count relation (and not the upvotes and downvotes relations) is made visible, so users cannot see who voted for an item. For Facebook \u0026ldquo;likes\u0026rdquo;, usernames are visible, but that can be seen as an artifact of combining the Upvote concept with the Reaction concept.\nEventual consistency. Getting exact counts is generally not required, so common implementations scale by not requiring strong consistency. This means that a user who upvotes an item will generally see that item\u0026rsquo;s count increase, but may not see the effect of a simultaneous (or even earlier) upvote from another user until later.\nKnown uses. Universally used in all social media apps, typically for posts and comments. Facebook combines the Upvote, Reaction and Recommendation concepts into a single \u0026ldquo;Like\u0026rdquo; concept, with some confusing outcomes (for example, that an angry reactions counts as an upvote).\nSynchronizations. Commonly synchronized with authoring concepts (such as Comment and Post), and with Karma (where an upvote may be synchronized with a reward action, so that a user needs to obtain some number of upvotes before reaching a certain karma level).\n","permalink":"https://essenceofsoftware.com/posts/upvote/","summary":"An example of a concept catalog entry that defines a concept\u0026rsquo;s purpose, behavior and design issues.","title":"Upvote: An Example Concept"},{"content":"Coming soon!\n","permalink":"https://essenceofsoftware.com/drafts/intro/","summary":"Coming soon!","title":"Concepts: A Brief Intro"},{"content":"I\u0026rsquo;m excited to have been invited by the ACM Practitioner Board to give a tech talk at noon Eastern Time on Dec 1, 2021.\n  Update: recording of the talk here\nThe Essence of Software (Or Why Systems Often Fail by Design, and How to Fix Them)\nWe’ve made great strides in software, but many systems are still hard to use or behave badly. Traditionally, we’ve looked to bugs in code to explain why systems go wrong—or to flaws in the user interface that may lead to misuse. In this talk, I’ll argue that the real problem often lies elsewhere: in the very concepts of the design. I’ll present a variety of surprising snags with familiar applications, from Dropbox to Gmail, and I’ll show how concepts can diagnose them and suggest fixes. I’ll explain in concrete and actionable terms what concepts are—essentially free-standing “nanoservices” that factor the behavior of a system into independent and reusable parts—and how you can apply them in your work, whether you’re a coder, program manager, software architect, UX designer, or consultant.\n","permalink":"https://essenceofsoftware.com/posts/acm-tech-talk/","summary":"Now updated with talk recording.","title":"ACM tech talk"},{"content":"You can download a free sample chapter from the book here.\n","permalink":"https://essenceofsoftware.com/posts/sample-chapter/","summary":"Download a free sample chapter.","title":"Sample chapter"},{"content":"Test A refers to testb\n","permalink":"https://essenceofsoftware.com/posts/testa/","summary":"Test A","title":"Test A"}]